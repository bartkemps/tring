<#@ template debug="false" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>
<#+
// Helper for type info
class PairTypeInfo {
    public string Name;
    public string BaseType;
    public string StorageType;
    public int BitWidth;
    public PairTypeInfo(string name, string baseType, string storageType, int bitWidth) {
        Name = name;
        BaseType = baseType;
        StorageType = storageType;
        BitWidth = bitWidth;
    }
}
#>
<#
var types = new List<PairTypeInfo> {
    new PairTypeInfo("BytePair",   "byte",   "ushort", 8),
    new PairTypeInfo("UInt16Pair", "ushort", "uint",   16),
    new PairTypeInfo("UInt32Pair", "uint",   "ulong",  32),
    new PairTypeInfo("UInt64Pair", "ulong",  "struct", 64), // Special case
};
foreach (var t in types) {
    var fileContent = GeneratePairStruct(t);
    var outputFilePath = Host.ResolvePath($"{t.Name}.cs");
    File.WriteAllText(outputFilePath, fileContent);
}
#>
LastGenerated = <#= DateTime.Now.ToString() #>
<#+
string GeneratePairStruct(PairTypeInfo t) {
    if (t.Name == "UInt64Pair") {
        // Special case: can't pack two ulongs into a single primitive, so use two fields
        return $@"namespace Tring.Numbers;

internal readonly struct UInt64Pair(ulong negative, ulong positive)
{{
    public ulong Negative {{ get; }} = negative;
    public ulong Positive {{ get; }} = positive;
}}
";
    }
    var shift = t.BitWidth;
    return $@"namespace Tring.Numbers;

internal readonly struct {t.Name}({t.BaseType} negative, {t.BaseType} positive)
{{
    private readonly {t.StorageType} packed = (({t.StorageType})negative << {shift}) | positive;
    public {t.BaseType} Negative => ({t.BaseType})(packed >> {shift});
    public {t.BaseType} Positive => ({t.BaseType})packed;
}}
";
}
#>

