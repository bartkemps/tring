<#@ template language="C#" hostspecific="True" #>
<#@ output extension=".cs" #>
// <auto-generated />
namespace Tring.Operators;

using System;
using Numbers;
public partial class UnaryOperation
{
<#
var types = new[] {
    new { BitsType = "UInt32", BitsTypeMaxValue = "UInt32.MaxValue" },
    new { BitsType = "UInt64", BitsTypeMaxValue = "UInt64.MaxValue" }
};
foreach (var t in types) {
#>

    private static readonly Func<<#= t.BitsType #>, <#= t.BitsType #>, <#= t.BitsType #>Pair>[] operations<#= t.BitsType.Replace("UInt", "").Replace("Int", "") #> =
    [
        Negative, Decrement, IsPositive,
        NegateAbsoluteValue, Ceil, Identity,
        IsZero, KeepNegative, IsNotNegative,
        CeilIsNegative, CeilIsNotZero, KeepPositive,
        CeilIsNotPositive, Zero, Floor,
        CyclicIncrement, FloorIsZero, Increment,
        IsNegative, CyclicDecrement, IsNotZero,
        Negate, FloorIsNegative, AbsoluteValue,
        IsNotPositive, FloorIsNotPositive, Positive
    ];

    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    internal static <#= t.BitsType #>Pair Apply(<#= t.BitsType #> negative, <#= t.BitsType #> positive, Func<<#= t.BitsType #>, <#= t.BitsType #>, <#= t.BitsType #>Pair> operation) => operation(negative, positive);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair Negative(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (<#= t.BitsTypeMaxValue #>, 0);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair Decrement(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (negative | ~positive, 0);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair IsPositive(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (negative | ~positive, positive);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair NegateAbsoluteValue(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (negative | positive, 0);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair Ceil(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (negative, 0);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair Identity(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (negative, positive);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair IsZero(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (negative | positive, ~negative & ~positive);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair KeepNegative(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (negative, ~negative & ~positive);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair IsNotNegative(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (negative, ~negative);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair CeilIsNegative(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (~negative, 0);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair CeilIsNotZero(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (~positive & ~negative, 0);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair KeepPositive(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (~positive & ~negative, positive);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair CeilIsNotPositive(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (positive, 0);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair Zero(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (0, 0);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair Floor(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (0, positive & ~negative);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair CyclicIncrement(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (positive, ~negative & ~positive);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair FloorIsZero(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (0, ~positive & ~negative);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair Increment(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (0, positive | ~negative);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair IsNegative(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (~negative, negative);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair CyclicDecrement(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (~positive & ~negative, negative);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair IsNotZero(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (~negative & ~positive, negative | positive);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair Negate(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (positive, negative);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair FloorIsNegative(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (0, negative);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair AbsoluteValue(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (0, positive | negative);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair IsNotPositive(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (positive, ~positive);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair FloorIsNotPositive(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (0, ~positive);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    private static <#= t.BitsType #>Pair Positive(<#= t.BitsType #> negative, <#= t.BitsType #> positive) => new (0, <#= t.BitsTypeMaxValue #>);
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    internal static <#= t.BitsType #>Pair Apply(<#= t.BitsType #> negative, <#= t.BitsType #> positive, Func<Trit, Trit> operation)
    {
        return operations<#= t.BitsType.Replace("UInt", "").Replace("Int", "") #>[13 + operation(Trit.Positive).Value + 3 * operation(Trit.Zero).Value + 9 * operation(Trit.Negative).Value](negative, positive);
    }
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    internal static <#= t.BitsType #>Pair Apply(<#= t.BitsType #> negative, <#= t.BitsType #> positive, Trit[] table)
    {
        if (table.Length != 3) throw new ArgumentException("Table must have exactly 3 elements.", nameof(table));
        return operations<#= t.BitsType.Replace("UInt", "").Replace("Int", "") #>[13 + table[2].Value + 3 * table[1].Value + 9 * table[0].Value](negative, positive);
    }
<# } #>
}
