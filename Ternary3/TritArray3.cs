// <auto-generated />
#nullable enable
namespace Ternary3;

using Formatting;
using Operators;
using System.Diagnostics;
using TritArrays;

/// <summary>
/// Represents a fixed-size array of 3 trits (ternary digits).
/// </summary>
[DebuggerDisplay("{DebugView()}")]
public struct TritArray3 : ITritArray<TritArray3>
{
    private const Byte BitMask = 0b111;
    private const int NumberOfTrits = 3;
    internal Byte Positive;
    internal Byte Negative;

    /// <summary>
    /// Represents the minimum value that a TritArray3 can have (all trits set to -1).
    /// </summary>
    public static readonly TritArray3 MinValue = new(BitMask, 0);

    /// <summary>
    /// Represents the maximum value that a TritArray3 can have (all trits set to 1).
    /// </summary>
    public static readonly TritArray3 MaxValue = new(0, BitMask);

    /// <summary>
    /// Represents a TritArray3 with all trits set to zero.
    /// </summary>
    public static readonly TritArray3 Zero = new();

    /// <summary>
    /// Initializes a new instance of the TritArray3 struct with all trits set to zero.
    /// </summary>
    public TritArray3()
    {
    }

    private TritArray3(BytePair trits)
    {
        Negative = trits.Negative;
        Positive = trits.Positive;
    }

    /// <summary>
    /// Initializes a new instance of the TritArray3 struct with the specified negative and positive bits.
    /// </summary>
    /// <param name="negative">The negative bits representing the trits.</param>
    /// <param name="positive">The positive bits representing the trits.</param>
    internal TritArray3(Byte negative, Byte positive)
    {
        Negative = negative;
        Positive = positive;
    }
    
    /// <summary>
    /// Parses a string representation of a TritArray3.
    /// </summary>
    /// <param name="value">The string value to parse.</param>
    /// <returns>A TritArray3 representing the parsed value.</returns>
    public static TritArray3 Parse(string value) => Parser.ParseTritArray3(value);
    
    /// <summary>
    /// Parses a string representation of a TritArray3.
    /// </summary>
    /// <param name="value">The string value to parse.</param>
    /// <param name="format">The format to use for parsing.</param>
    /// <returns>A TritArray3 representing the parsed value.</returns>
    public static TritArray3 Parse(string value, ITernaryFormat format) => Parser.ParseTritArray3(value, format);
    
    /// <summary>
    /// Parses a string representation of a TritArray3.
    /// </summary>
    /// <param name="value">The string value to parse.</param>
    /// <param name="options">The options to use for parsing.</param>
    /// <returns>A TritArray3 representing the parsed value.</returns>
    public static TritArray3 Parse(string value, TritParseOptions options) => Parser.ParseTritArray3(value, null, options);
    
    /// <summary>
    /// Parses a string representation of a TritArray3.
    /// </summary>
    /// <param name="value">The string value to parse.</param>
    /// <param name="format">The format to use for parsing.</param>
    /// <param name="options">The options to use for parsing.</param>
    /// <returns>A TritArray3 representing the parsed value.</returns>
    public static TritArray3 Parse(string value, ITernaryFormat format, TritParseOptions options) => Parser.ParseTritArray3(value, format, options);

     /// <intheritdoc/>
    public Trit this[int index]
    {
        get => index is >= 0 and < NumberOfTrits 
                ? TritConverter.GetTrit(Negative, Positive, index)
                : throw new ArgumentOutOfRangeException(nameof(index), $"Index must be between 0 and {NumberOfTrits-1}.");
        set
        {
            if (index is < 0 or >= NumberOfTrits)
            {
                throw new ArgumentOutOfRangeException(nameof(index), $"Index must be between 0 and {NumberOfTrits-1}.");
            }
            TritConverter.SetTrit(ref Negative, ref Positive, index, value);
        }
    }
    
    /// <intheritdoc/>
    public ITritArray this[Range range]
    {
        get
        {
            Splicer.Splice(Negative, Positive, Length, range, out var negative, out var positive, out var length);
            return new TritArray(negative, positive, (byte)length);
        }
    }
    
    /// <summary>
    /// Gets or sets the trit at the specified index.
    /// </summary>
    /// <param name="index">The zero-based index of the trit to get or set (must be between 0 and 26).</param>
    /// <returns>The trit at the specified index.</returns>
    /// <exception cref="ArgumentOutOfRangeException">Thrown when index is less than 0 or greater than 26.</exception>
    public Trit this[Index index]
    {
        get => index.IsFromEnd ? this[NumberOfTrits - index.Value] : this[index.Value];
        set
        {
            if (index.IsFromEnd)
            {
                this[NumberOfTrits - index.Value] = value;
            }
            else
            {
                this[index.Value] = value;
            }
        }
    }

    /// <summary>
    /// Gets the length of the trit array, which is always 3.
    /// </summary>
    public int Length => NumberOfTrits;

    /// <summary>
    /// Applies a unary operation to each trit in the array.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="operation">The unary operation to apply to each trit.</param>
    /// <returns>A new TritArray3 with the operation applied to each trit.</returns>
    public static TritArray3 operator |(TritArray3 array, Func<Trit, Trit> operation)
        => array | new UnaryTritOperator(operation);

    /// <summary>
    /// Applies a lookup table operation to each trit in the array.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="table">The lookup table containing the transformation values.</param>
    /// <returns>A new TritArray3 with the lookup operation applied to each trit.</returns>
    public static TritArray3 operator |(TritArray3 array, Trit[] table)
        => array | new UnaryTritOperator(table);

    /// <summary>
    /// Creates a binary operation context for this array.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="operation">The binary operation to be applied.</param>
    /// <returns>A LookupTritArray3Operator that can be used to apply the operation with another array.</returns>
    public static LookupTritArray3Operator operator |(TritArray3 array, Func<Trit, Trit, Trit> operation)
        => new LookupTritArray3Operator(array, operation);

    /// <summary>
    /// Creates a binary operation context for this array using a lookup table.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="table">The lookup table containing the transformation values.</param>
    /// <returns>A LookupTritArray3Operator that can be used to apply the operation with another array.</returns>
    public static LookupTritArray3Operator operator |(TritArray3 array, BinaryTritOperator table)
        => new LookupTritArray3Operator(array, table);

    /// <summary>
    /// Creates a binary operation context for this array using a 2D lookup table.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="table">The 2D lookup table containing the transformation values.</param>
    /// <returns>A LookupTritArray3Operator that can be used to apply the operation with another array.</returns>
    public static LookupTritArray3Operator operator |(TritArray3 array, Trit[,] table)
        => new LookupTritArray3Operator(array, table);


    /// <summary>
    /// Performs a left bitwise shift on the trit array.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="shift">The number of positions to shift.</param>
    /// <returns>A new TritArray3 with the bits shifted to the left.</returns>
    public static TritArray3 operator <<(TritArray3 array, int shift)
    {
        return shift switch
        {
            >= NumberOfTrits => Zero,
            < 0 => array >> -shift,
            _ => new() { Positive = (Byte)((array.Positive << shift) & BitMask), Negative = (Byte)((array.Negative << shift) & BitMask) }
        };
    }

    /// <summary>
    /// Performs a right bitwise shift on the trit array.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="shift">The number of positions to shift.</param>
    /// <returns>A new TritArray3 with the bits shifted to the right.</returns>
    public static TritArray3 operator >> (TritArray3 array, int shift)
    {
        return shift switch
        {
            >= NumberOfTrits => Zero,
            < 0 => array << -shift,
            _ => new() { Positive = (Byte)(array.Positive >> shift), Negative = (Byte)(array.Negative >> shift) }
        };
    }

    /// <summary>
    /// Adds two TritArray3 values together.
    /// </summary>
    /// <param name="value1">The first value to add.</param>
    /// <param name="value2">The second value to add.</param>
    /// <returns>A new TritArray3 representing the sum of the two values.</returns>
    public static TritArray3 operator +(TritArray3 value1, TritArray3 value2)
    {
        Calculator.AddBalancedTernary(value1.Negative, value1.Positive, value2.Negative, value2.Positive, out var negative, out var positive);
        return new() { Negative = (Byte)negative, Positive = (Byte)positive };
    }

    /// <summary>
    /// Subtracts one TritArray3 value from another.
    /// </summary>
    /// <param name="value1">The value to subtract from.</param>
    /// <param name="value2">The value to subtract.</param>
    /// <returns>A new TritArray3 representing the difference between the two values.</returns>
    public static TritArray3 operator -(TritArray3 value1, TritArray3 value2)
    {
        Calculator.AddBalancedTernary(value1.Negative, value1.Positive, value2.Positive, value2.Negative, out var negative, out var positive);
        return new() { Negative = (Byte)negative, Positive = (Byte)positive };
    }

    #region Conversion Operators

    /// <summary>
    /// Creates a TritArray3 from an integer value.
    /// </summary>
    /// <param name="value">The integer value to convert.</param>
    /// <returns>A new TritArray3 representing the value in balanced ternary.</returns>
    private static TritArray3 Create(long value)
    {
        TritConverter.To32Trits(value, out var negative, out var positive);
        return new() { Negative = (Byte)negative, Positive = (Byte)positive };
    }

    /// <summary>
    /// Defines an implicit conversion of an Int3T to a TritArray3.
    /// </summary>
    /// <param name="value">The Int3T value to convert.</param>
    /// <returns>A TritArray3 representing the same value.</returns>
    public static implicit operator TritArray3(Int3T value)
    {
        // Cast to long to get the numeric value instead of trying to access a non-existent Value property
        TritConverter.To32Trits(value, out var negative, out var positive);
        return new() { Negative = (Byte)negative, Positive = (Byte)positive };
    }

    /// <summary>
    /// Defines an implicit conversion of a TritArray3 to an Int3T.
    /// </summary>
    /// <param name="array">The TritArray3 to convert.</param>
    /// <returns>An Int3T representing the same value.</returns>
    public static implicit operator Int3T(TritArray3 array) => (SByte)TritConverter.ToInt32(array.Negative, array.Positive);
    
    
       /// <summary>
       /// Defines an implicit conversion of a sbyte to a TritArray3.
       /// </summary>
       /// <param name="value">The sbyte value to convert.</param>
       /// <returns>A TritArray3 representing the same value.</returns>
       public static implicit operator TritArray3(sbyte value) => Create(value);

       /// <summary>
       /// Defines an implicit conversion of a TritArray3 to a sbyte.
       /// </summary>
       /// <param name="array">The TritArray3 to convert.</param>
       /// <returns>A sbyte representing the same value.</returns>
       public static implicit operator sbyte(TritArray3 array) => (sbyte)TritConverter.ToInt32(array.Negative & BitMask, array.Positive & BitMask);

       /// <summary>
       /// Defines an explicit conversion of an int to a TritArray3.
       /// </summary>
       /// <param name="value">The int value to convert.</param>
       /// <returns>A TritArray3 representing the same value.</returns>
       public static explicit operator TritArray3(int value) => Create(value);

       /// <summary>
       /// Defines an implicit conversion of a TritArray3 to an int.
       /// </summary>
       /// <param name="array">The TritArray3 to convert.</param>
       /// <returns>An int representing the same value.</returns>
       public static implicit operator int(TritArray3 array) => (int)TritConverter.ToInt32(array.Negative & BitMask, array.Positive & BitMask);

       /// <summary>
       /// Defines an explicit conversion of a long to a TritArray3.
       /// </summary>
       /// <param name="value">The long value to convert.</param>
       /// <returns>A TritArray3 representing the same value.</returns>
       public static explicit operator TritArray3(long value) => Create(value);

       /// <summary>
       /// Defines an implicit conversion of a TritArray3 to a long.
       /// </summary>
       /// <param name="array">The TritArray3 to convert.</param>
       /// <returns>A long representing the same value.</returns>
       public static implicit operator long(TritArray3 array) => TritConverter.ToInt64(array.Negative & BitMask, array.Positive & BitMask);

    #endregion

    /// <inheritdoc/>   
    public override int GetHashCode() => HashCode.Combine(Negative.GetHashCode(), Positive.GetHashCode());
    
    /// <inheritdoc/>  
    public override bool Equals(object? obj) => obj is TritArray3 other && Equals(other); 
    
    /// <inheritdoc/>  
    public bool Equals(TritArray3 other) => Negative == other.Negative && Positive == other.Positive;
    
    internal string DebugView() => $"{this} ({this:ter})";

    // ToString implementation
    /// <summary>
    /// Returns a string representation of the TritArray3.
    /// </summary>
    public override string ToString() => Formatter.Format(this, null, null);
    /// <summary>
    /// Returns a string representation of the TritArray3.
    /// </summary>
    public string ToString(string? format) =>Formatter.Format(this, format, null);
    /// <summary>
    /// Returns a string representation of the TritArray3.
    /// </summary>
    public string ToString(IFormatProvider? provider) => Formatter.Format(this, null, provider);
    /// <summary>
    /// Returns a string representation of the TritArray3.
    /// </summary>
    public string ToString(string? format, IFormatProvider? provider) =>Formatter.Format(this, format, provider);
    /// <summary>
   /// Returns a string representation of this instance, formatted balanced ternarily according to the specified format.
    /// </summary>
    public string ToString(ITernaryFormat format) => Formatter.Format((ITritArray)this, format);
}