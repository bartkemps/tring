<#@ template debug="false" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>
<#
    // Define the trit array sizes to generate
            var tritArraySizes = new List<(int Trits, string BackingType, string IntBackingType)>
            {
                (3, "Byte", "SByte"),
                (9, "UInt16", "Int16"),
                (27, "UInt32", "Int64")
            };

            // Loop through each size and generate its file
            foreach (var size in tritArraySizes)
            {
                // Generate the file content
                var fileContent = GenerateTritArrayClass(
                    size.Trits,
                    size.BackingType,
                    size.IntBackingType
                    );

                // Determine the output file path
                var outputFilePath = Host.ResolvePath($"TritArray{size.Trits}.cs");

                // Write the content to the file
                File.WriteAllText(outputFilePath, fileContent);
            }
#>
LastGenerated = <#= DateTime.Now.ToString() #>

<#+
// This method generates the code for a TritArrayN class
    private string GenerateTritArrayClass(int trits, string backingType, string intBackingType)
    {
        return $$"""
           // <auto-generated />
           #nullable enable
           namespace Ternary3;
           
           using Formatting;
           using Operators;
           using System.Diagnostics;
           using TritArrays;
           
           /// <summary>
           /// Represents a fixed-size array of {{trits}} trits (ternary digits).
           /// </summary>
           [DebuggerDisplay("{DebugView()}")]
           public struct TritArray{{trits}} : ITritArray<TritArray{{trits}}>
           {
               private const {{backingType}} BitMask = 0b{{new string('1', trits)}};
               private const int NumberOfTrits = {{trits}};
               internal {{backingType}} Positive;
               internal {{backingType}} Negative;

               /// <summary>
               /// Represents the minimum value that a TritArray{{trits}} can have (all trits set to -1).
               /// </summary>
               public static readonly TritArray{{trits}} MinValue = new(BitMask, 0);

               /// <summary>
               /// Represents the maximum value that a TritArray{{trits}} can have (all trits set to 1).
               /// </summary>
               public static readonly TritArray{{trits}} MaxValue = new(0, BitMask);

               /// <summary>
               /// Represents a TritArray{{trits}} with all trits set to zero.
               /// </summary>
               public static readonly TritArray{{trits}} Zero = new();

               /// <summary>
               /// Initializes a new instance of the TritArray{{trits}} struct with all trits set to zero.
               /// </summary>
               public TritArray{{trits}}()
               {
               }

               private TritArray{{trits}}({{backingType}}Pair trits)
               {
                   Negative = trits.Negative;
                   Positive = trits.Positive;
               }

               /// <summary>
               /// Initializes a new instance of the TritArray{{trits}} struct with the specified negative and positive bits.
               /// </summary>
               /// <param name="negative">The negative bits representing the trits.</param>
               /// <param name="positive">The positive bits representing the trits.</param>
               internal TritArray{{trits}}({{backingType}} negative, {{backingType}} positive)
               {
                   Negative = negative;
                   Positive = positive;
               }

                /// <intheritdoc/>
               public Trit this[int index]
               {
                   get => index is >= 0 and < NumberOfTrits 
                           ? TritConverter.GetTrit(Negative, Positive, index)
                           : throw new ArgumentOutOfRangeException(nameof(index), $"Index must be between 0 and {NumberOfTrits-1}.");
                   set
                   {
                       if (index is < 0 or >= NumberOfTrits)
                       {
                           throw new ArgumentOutOfRangeException(nameof(index), $"Index must be between 0 and {NumberOfTrits-1}.");
                       }
                       TritConverter.SetTrit(ref Negative, ref Positive, index, value);
                   }
               }
               
               /// <intheritdoc/>
               public ITritArray this[Range range]
               {
                   get
                   {
                       Splicer.Splice(Negative, Positive, Length, range, out var negative, out var positive, out var length);
                       return new TritArray(negative, positive, (byte)length);
                   }
               }
               
               /// <summary>
               /// Gets or sets the trit at the specified index.
               /// </summary>
               /// <param name="index">The zero-based index of the trit to get or set (must be between 0 and 26).</param>
               /// <returns>The trit at the specified index.</returns>
               /// <exception cref="ArgumentOutOfRangeException">Thrown when index is less than 0 or greater than 26.</exception>
               public Trit this[Index index]
               {
                   get => index.IsFromEnd ? this[NumberOfTrits - index.Value] : this[index.Value];
                   set
                   {
                       if (index.IsFromEnd)
                       {
                           this[NumberOfTrits - index.Value] = value;
                       }
                       else
                       {
                           this[index.Value] = value;
                       }
                   }
               }
           
               /// <summary>
               /// Gets the length of the trit array, which is always {{trits}}.
               /// </summary>
               public int Length => NumberOfTrits;
           
               /// <summary>
               /// Applies a unary operation to each trit in the array.
               /// </summary>
               /// <param name="array">The source array.</param>
               /// <param name="operation">The unary operation to apply to each trit.</param>
               /// <returns>A new TritArray{{trits}} with the operation applied to each trit.</returns>
               public static TritArray{{trits}} operator |(TritArray{{trits}} array, Func<Trit, Trit> operation)
                   => array | new UnaryTritOperator(operation);
           
               /// <summary>
               /// Applies a lookup table operation to each trit in the array.
               /// </summary>
               /// <param name="array">The source array.</param>
               /// <param name="table">The lookup table containing the transformation values.</param>
               /// <returns>A new TritArray{{trits}} with the lookup operation applied to each trit.</returns>
               public static TritArray{{trits}} operator |(TritArray{{trits}} array, Trit[] table)
                   => array | new UnaryTritOperator(table);
           
               /// <summary>
               /// Creates a binary operation context for this array.
               /// </summary>
               /// <param name="array">The source array.</param>
               /// <param name="operation">The binary operation to be applied.</param>
               /// <returns>A LookupTritArray{{trits}}Operator that can be used to apply the operation with another array.</returns>
               public static LookupTritArray{{trits}}Operator operator |(TritArray{{trits}} array, Func<Trit, Trit, Trit> operation)
                   => new LookupTritArray{{trits}}Operator(array, operation);
           
               public static LookupTritArray{{trits}}Operator operator |(TritArray{{trits}} array, BinaryTritOperator table)
                   => new LookupTritArray{{trits}}Operator(array, table);
           
               public static LookupTritArray{{trits}}Operator operator |(TritArray{{trits}} array, Trit[,] table)
                   => new LookupTritArray{{trits}}Operator(array, table);
           
           
               /// <summary>
               /// Performs a left bitwise shift on the trit array.
               /// </summary>
               /// <param name="array">The source array.</param>
               /// <param name="shift">The number of positions to shift.</param>
               /// <returns>A new TritArray{{trits}} with the bits shifted to the left.</returns>
               public static TritArray{{trits}} operator <<(TritArray{{trits}} array, int shift)
               {
                   return shift switch
                   {
                       >= NumberOfTrits => Zero,
                       < 0 => array >> -shift,
                       _ => new() { Positive = ({{backingType}})((array.Positive << shift) & BitMask), Negative = ({{backingType}})((array.Negative << shift) & BitMask) }
                   };
               }
           
               /// <summary>
               /// Performs a right bitwise shift on the trit array.
               /// </summary>
               /// <param name="array">The source array.</param>
               /// <param name="shift">The number of positions to shift.</param>
               /// <returns>A new TritArray{{trits}} with the bits shifted to the right.</returns>
               public static TritArray{{trits}} operator >> (TritArray{{trits}} array, int shift)
               {
                   return shift switch
                   {
                       >= NumberOfTrits => Zero,
                       < 0 => array << -shift,
                       _ => new() { Positive = ({{backingType}})(array.Positive >> shift), Negative = ({{backingType}})(array.Negative >> shift) }
                   };
               }
           
               /// <summary>
               /// Adds two TritArray{{trits}} values together.
               /// </summary>
               /// <param name="value1">The first value to add.</param>
               /// <param name="value2">The second value to add.</param>
               /// <returns>A new TritArray{{trits}} representing the sum of the two values.</returns>
               public static TritArray{{trits}} operator +(TritArray{{trits}} value1, TritArray{{trits}} value2)
               {
                   Calculator.AddBalancedTernary(value1.Negative, value1.Positive, value2.Negative, value2.Positive, out var negative, out var positive);
                   return new() { Negative = ({{backingType}})negative, Positive = ({{backingType}})positive };
               }
           
               /// <summary>
               /// Subtracts one TritArray{{trits}} value from another.
               /// </summary>
               /// <param name="value1">The value to subtract from.</param>
               /// <param name="value2">The value to subtract.</param>
               /// <returns>A new TritArray{{trits}} representing the difference between the two values.</returns>
               public static TritArray{{trits}} operator -(TritArray{{trits}} value1, TritArray{{trits}} value2)
               {
                   Calculator.AddBalancedTernary(value1.Negative, value1.Positive, value2.Positive, value2.Negative, out var negative, out var positive);
                   return new() { Negative = ({{backingType}})negative, Positive = ({{backingType}})positive };
               }
           
               #region Conversion Operators

               /// <summary>
               /// Creates a TritArray{{trits}} from an integer value.
               /// </summary>
               /// <param name="value">The integer value to convert.</param>
               /// <returns>A new TritArray{{trits}} representing the value in balanced ternary.</returns>
               private static TritArray{{trits}} Create(long value)
               {
                   TritConverter.To32Trits(value, out var negative, out var positive);
                   return new() { Negative = ({{backingType}})negative, Positive = ({{backingType}})positive };
               }

               /// <summary>
               /// Defines an implicit conversion of an Int{{trits}}T to a TritArray{{trits}}.
               /// </summary>
               /// <param name="value">The Int{{trits}}T value to convert.</param>
               /// <returns>A TritArray{{trits}} representing the same value.</returns>
               public static implicit operator TritArray{{trits}}(Int{{trits}}T value)
               {
                   // Cast to long to get the numeric value instead of trying to access a non-existent Value property
                   TritConverter.To32Trits(value, out var negative, out var positive);
                   return new() { Negative = ({{backingType}})negative, Positive = ({{backingType}})positive };
               }
           
               /// <summary>
               /// Defines an implicit conversion of a TritArray{{trits}} to an Int{{trits}}T.
               /// </summary>
               /// <param name="array">The TritArray{{trits}} to convert.</param>
               /// <returns>An Int{{trits}}T representing the same value.</returns>
               public static implicit operator Int{{trits}}T(TritArray{{trits}} array) => ({{intBackingType}})TritConverter.ToInt{{(intBackingType == "Int64" ? "64" : "32")}}(array.Negative, array.Positive);
               
               {{CreateConversionOperators(trits, intBackingType)}}

               #endregion

               /// <inheritdoc/>   
               public override int GetHashCode() => HashCode.Combine(Negative.GetHashCode(), Positive.GetHashCode());
               
               /// <inheritdoc/>  
               public override bool Equals(object? obj) => obj is TritArray{{trits}} other && Equals(other); 
               
               /// <inheritdoc/>  
               public bool Equals(TritArray{{trits}} other) => Negative == other.Negative && Positive == other.Positive;
               
               internal string DebugView() => $"{this} ({this:ter})";
           
               // ToString implementation
               /// <summary>
               /// Returns a string representation of the TritArray{{trits}}.
               /// </summary>
               public override string ToString() => Formatter.Format(this, null, null);
               /// <summary>
               /// Returns a string representation of the TritArray{{trits}}.
               /// </summary>
               public string ToString(string? format) =>Formatter.Format(this, format, null);
               /// <summary>
               /// Returns a string representation of the TritArray{{trits}}.
               /// </summary>
               public string ToString(IFormatProvider? provider) => Formatter.Format(this, null, provider);
               /// <summary>
               /// Returns a string representation of the TritArray{{trits}}.
               /// </summary>
               public string ToString(string? format, IFormatProvider? provider) =>Formatter.Format(this, format, provider);
               /// <summary>
              /// Returns a string representation of this instance, formatted balanced ternarily according to the specified format.
               /// </summary>
               public string ToString(ITernaryFormat format) => Formatter.Format((ITritArray)this, format);
           }
           """;
    }

    private string CreateConversionOperators(int trits, string intBackingType)
    {
        if (intBackingType == "SByte")
        {
    return $"""
       
                      /// <summary>
                      /// Defines an implicit conversion of a sbyte to a TritArray{trits}.
                      /// </summary>
                      /// <param name="value">The sbyte value to convert.</param>
                      /// <returns>A TritArray{trits} representing the same value.</returns>
                      public static implicit operator TritArray{trits}(sbyte value) => Create(value);
       
                      /// <summary>
                      /// Defines an implicit conversion of a TritArray{trits} to a sbyte.
                      /// </summary>
                      /// <param name="array">The TritArray{trits} to convert.</param>
                      /// <returns>A sbyte representing the same value.</returns>
                      public static implicit operator sbyte(TritArray{trits} array) => (sbyte)TritConverter.ToInt32(array.Negative & BitMask, array.Positive & BitMask);
       
                      /// <summary>
                      /// Defines an explicit conversion of an int to a TritArray{trits}.
                      /// </summary>
                      /// <param name="value">The int value to convert.</param>
                      /// <returns>A TritArray{trits} representing the same value.</returns>
                      public static explicit operator TritArray{trits}(int value) => Create(value);
       
                      /// <summary>
                      /// Defines an implicit conversion of a TritArray{trits} to an int.
                      /// </summary>
                      /// <param name="array">The TritArray{trits} to convert.</param>
                      /// <returns>An int representing the same value.</returns>
                      public static implicit operator int(TritArray{trits} array) => (int)TritConverter.ToInt32(array.Negative & BitMask, array.Positive & BitMask);
       
                      /// <summary>
                      /// Defines an explicit conversion of a long to a TritArray{trits}.
                      /// </summary>
                      /// <param name="value">The long value to convert.</param>
                      /// <returns>A TritArray{trits} representing the same value.</returns>
                      public static explicit operator TritArray{trits}(long value) => Create(value);
       
                      /// <summary>
                      /// Defines an implicit conversion of a TritArray{trits} to a long.
                      /// </summary>
                      /// <param name="array">The TritArray{trits} to convert.</param>
                      /// <returns>A long representing the same value.</returns>
                      public static implicit operator long(TritArray{trits} array) => TritConverter.ToInt64(array.Negative & BitMask, array.Positive & BitMask);
               """;
        }
        if (intBackingType == "Int16")
        {
            return $"""
       
                      /// <summary>
                      /// Defines an implicit conversion of a short to a TritArray{trits}.
                      /// </summary>
                      /// <param name="value">The short value to convert.</param>
                      /// <returns>A TritArray{trits} representing the same value.</returns>
                      public static implicit operator TritArray{trits}(short value) => Create(value);
       
                      /// <summary>
                      /// Defines an implicit conversion of a TritArray{trits} to a short.
                      /// </summary>
                      /// <param name="array">The TritArray{trits} to convert.</param>
                      /// <returns>A short representing the same value.</returns>
                      public static implicit operator short(TritArray{trits} array) => (short)TritConverter.ToInt32(array.Negative & BitMask, array.Positive & BitMask);
       
                      /// <summary>
                      /// Defines an explicit conversion of an int to a TritArray{trits}.
                      /// </summary>
                      /// <param name="value">The int value to convert.</param>
                      /// <returns>A TritArray{trits} representing the same value.</returns>
                      public static explicit operator TritArray{trits}(int value) => Create(value);
       
                      /// <summary>
                      /// Defines an implicit conversion of a TritArray{trits} to an int.
                      /// </summary>
                      /// <param name="array">The TritArray{trits} to convert.</param>
                      /// <returns>An int representing the same value.</returns>
                      public static implicit operator int(TritArray{trits} array) => (int)TritConverter.ToInt32(array.Negative & BitMask, array.Positive & BitMask);
       
                      /// <summary>
                      /// Defines an explicit conversion of a long to a TritArray{trits}.
                      /// </summary>
                      /// <param name="value">The long value to convert.</param>
                      /// <returns>A TritArray{trits} representing the same value.</returns>
                      public static explicit operator TritArray{trits}(long value) => Create(value);
       
                      /// <summary>
                      /// Defines an implicit conversion of a TritArray{trits} to a long.
                      /// </summary>
                      /// <param name="array">The TritArray{trits} to convert.</param>
                      /// <returns>A long representing the same value.</returns>
                      public static implicit operator long(TritArray{trits} array) => TritConverter.ToInt64(array.Negative & BitMask, array.Positive & BitMask);
               """;
        }
        // Int64
        return $"""
       
                      /// <summary>
                      /// Defines an implicit conversion of an int to a TritArray{trits}.
                      /// </summary>
                      /// <param name="value">The int value to convert.</param>
                      /// <returns>A TritArray{trits} representing the same value.</returns>
                      public static implicit operator TritArray{trits}(int value) => Create(value);
       
                      /// <summary>
                      /// Defines an explicit conversion of a TritArray{trits} to an int.
                      /// </summary>
                      /// <param name="array">The TritArray{trits} to convert.</param>
                      /// <returns>An int representing the same value.</returns>
                      public static explicit operator int(TritArray{trits} array) => (int)TritConverter.ToInt64(array.Negative & BitMask, array.Positive & BitMask);
       
                      /// <summary>
                      /// Defines an implicit conversion of a long to a TritArray{trits}.
                      /// </summary>
                      /// <param name="value">The long value to convert.</param>
                      /// <returns>A TritArray{trits} representing the same value.</returns>
                      public static implicit operator TritArray{trits}(long value) => Create(value);
       
                      /// <summary>
                      /// Defines an implicit conversion of a TritArray{trits} to a long.
                      /// </summary>
                      /// <param name="array">The TritArray{trits} to convert.</param>
                      /// <returns>A long representing the same value.</returns>
                      public static implicit operator long(TritArray{trits} array) => TritConverter.ToInt64(array.Negative & BitMask, array.Positive & BitMask);
               """;
    }
#>
