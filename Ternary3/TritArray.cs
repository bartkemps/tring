// <auto-generated />
#nullable enable
namespace Ternary3;

using Formatting;
using Operators;
using System.Diagnostics;
using System.Numerics;
using TritArrays;

/// <summary>
/// Represents a fixed-size array of 27 trits (ternary digits).
/// </summary>
[DebuggerDisplay("{DebugView()}")]
public struct TritArray : ITritArray<TritArray>
{
    private ulong BitMask => 2UL ^ NumberOfTrits - 1UL;
    internal readonly byte NumberOfTrits;
    internal ulong Positive;
    internal ulong Negative;

    /// <summary>
    /// Represents the minimum value that a TritArray can have (all trits set to -1).
    /// </summary>
    public readonly TritArray MinValue => new(ulong.MaxValue, 0, 64);

    /// <summary>
    /// Represents the maximum value that a TritArray can have (all trits set to 1).
    /// </summary>
    public readonly TritArray MaxValue => new(0, ulong.MaxValue, 64);

    /// <summary>
    /// Represents a TritArray with all trits set to zero.
    /// </summary>
    public static readonly TritArray Zero = new(0,0,0);

    /// <summary>
    /// Initializes a new instance of the TritArray struct with all trits set to zero.
    /// </summary>
    public TritArray()
    {
    }

    /// <summary>
    /// Initializes a new instance of the TritArray struct with the specified negative and positive bits.
    /// </summary>
    /// <param name="negative">The negative bits representing the trits.</param>
    /// <param name="positive">The positive bits representing the trits.</param>
    /// <param name="length">The length of the array.</param>
    internal TritArray(ulong negative, ulong positive, byte length)
    {
        Negative = negative;
        Positive = positive;
        NumberOfTrits = length;
    }

    /// <intheritdoc/>
    public Trit this[int index]
    {
        get => index >= 0 && index < NumberOfTrits
                ? TritConverter.GetTrit(Negative, Positive, index)
                : throw new ArgumentOutOfRangeException(nameof(index), $"Index must be between 0 and {NumberOfTrits - 1}.");
        set
        {
            if (index < 0 || index >= NumberOfTrits)
            {
                throw new ArgumentOutOfRangeException(nameof(index), $"Index must be between 0 and {NumberOfTrits - 1}.");
            }
            TritConverter.SetTrit(ref Negative, ref Positive, index, value);
        }
    }

    /// <intheritdoc/>
    public ITritArray this[Range range]
    {
        get
        {
            Splicer.Splice(Negative, Positive, Length, range, out var negative, out var positive, out var length);
            return new TritArray(negative, positive, (byte)length);
        }
    }

    /// <summary>
    /// Gets or sets the trit at the specified index.
    /// </summary>
    /// <param name="index">The zero-based index of the trit to get or set (must be between 0 and 26).</param>
    /// <returns>The trit at the specified index.</returns>
    /// <exception cref="ArgumentOutOfRangeException">Thrown when index is less than 0 or greater than 26.</exception>
    public Trit this[Index index]
    {
        get => index.IsFromEnd ? this[NumberOfTrits - index.Value] : this[index.Value];
        set
        {
            if (index.IsFromEnd)
            {
                this[NumberOfTrits - index.Value] = value;
            }
            else
            {
                this[index.Value] = value;
            }
        }
    }

    /// <summary>
    /// Gets the length of the trit array
    /// </summary>
    public int Length => NumberOfTrits;

    /// <summary>
    /// Applies a unary operation to each trit in the array.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="operation">The unary operation to apply to each trit.</param>
    /// <returns>A new TritArray with the operation applied to each trit.</returns>
    public static TritArray operator |(TritArray array, Func<Trit, Trit> operation)
        => array | new UnaryTritOperator(operation);

    /// <summary>
    /// Applies a lookup table operation to each trit in the array.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="table">The lookup table containing the transformation values.</param>
    /// <returns>A new TritArray with the lookup operation applied to each trit.</returns>
    public static TritArray operator |(TritArray array, Trit[] table)
        => array | new UnaryTritOperator(table);

    /// <summary>
    /// Creates a binary operation context for this array.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="operation">The binary operation to be applied.</param>
    /// <returns>A LookupTritArrayOperator that can be used to apply the operation with another array.</returns>
    public static LookupTritArrayOperator operator |(TritArray array, Func<Trit, Trit, Trit> operation)
        => new LookupTritArrayOperator(array, operation);

    public static LookupTritArrayOperator operator |(TritArray array, BinaryTritOperator table)
        => new LookupTritArrayOperator(array, table);

    public static LookupTritArrayOperator operator |(TritArray array, Trit[,] table)
        => new LookupTritArrayOperator(array, table);


    /// <summary>
    /// Performs a left bitwise shift on the trit array.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="shift">The number of positions to shift.</param>
    /// <returns>A new TritArray with the bits shifted to the left.</returns>
    public static TritArray operator <<(TritArray array, int shift)
    {
        if (shift == 0) return array;
        if (shift >= array.NumberOfTrits) return Zero;
        var bitMask = array.BitMask;
        if (shift < 0) return new(array.Negative >> -shift, array.Positive >> -shift, array.NumberOfTrits);
        return new((array.Negative << shift) & bitMask, (array.Positive << shift) & bitMask, array.NumberOfTrits);
    }

    /// <summary>
    /// Performs a right bitwise shift on the trit array.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="shift">The number of positions to shift.</param>
    /// <returns>A new TritArray with the bits shifted to the right.</returns>
    public static TritArray operator >>(TritArray array, int shift)
    {
        if (shift == 0) return array;
        if (shift >= array.NumberOfTrits) return Zero;
        var bitMask = array.BitMask;
        if (shift < 0) return new(array.Negative << -shift, array.Positive << -shift, array.NumberOfTrits);
        return new((array.Negative >> shift) & bitMask, (array.Positive >> shift) & bitMask, array.NumberOfTrits);
    }

    /// <summary>
    /// Adds two TritArray values together.
    /// </summary>
    /// <param name="value1">The first value to add.</param>
    /// <param name="value2">The second value to add.</param>
    /// <returns>A new TritArray representing the sum of the two values.</returns>
    public static TritArray operator +(TritArray value1, TritArray value2)
    {
        Calculator.AddBalancedTernary(value1.Negative, value1.Positive, value2.Negative, value2.Positive, out var negative, out var positive);
        var length = 64-BitOperations.LeadingZeroCount(negative | positive);
        return new(negative, positive, (byte)length);
    }

    /// <summary>
    /// Subtracts one TritArray value from another.
    /// </summary>
    /// <param name="value1">The value to subtract from.</param>
    /// <param name="value2">The value to subtract.</param>
    /// <returns>A new TritArray representing the difference between the two values.</returns>
    public static TritArray operator -(TritArray value1, TritArray value2)
    {
        Calculator.AddBalancedTernary(value1.Negative, value1.Positive, value2.Positive, value2.Negative, out var negative, out var positive);
        var length = 64-BitOperations.LeadingZeroCount(negative | positive);
        return new(negative, positive, (byte)length);
    }

    #region Conversion Operators

    /// <summary>
    /// Creates a TritArray from an integer value.
    /// </summary>
    /// <param name="value">The integer value to convert.</param>
    /// <returns>A new TritArray representing the value in balanced ternary.</returns>
    private static TritArray Create(long value)
    {
        TritConverter.To32Trits(value, out var negative, out var positive);
        var length = 64-BitOperations.LeadingZeroCount(negative | positive);
        return new(negative, positive, (byte)length);
    }

    /// <summary>
    /// Defines an implicit conversion of an Int27T to a TritArray.
    /// </summary>
    /// <param name="value">The Int27T value to convert.</param>
    /// <returns>A TritArray representing the same value.</returns>
    public static implicit operator TritArray(Int27T value)
    {
        // Cast to long to get the numeric value instead of trying to access a non-existent Value property
        TritConverter.To32Trits(value, out var negative, out var positive);
        var length = 64-BitOperations.LeadingZeroCount(negative | positive);
        return new(negative, positive, (byte)length);
    }

    /// <summary>
    /// Defines an implicit conversion of a TritArray to an Int27T.
    /// </summary>
    /// <param name="array">The TritArray to convert.</param>
    /// <returns>An Int27T representing the same value.</returns>
    public static implicit operator Int27T(TritArray array) => (Int64)TritConverter.ToInt64(array.Negative, array.Positive);


    /// <summary>
    /// Defines an implicit conversion of an int to a TritArray.
    /// </summary>
    /// <param name="value">The int value to convert.</param>
    /// <returns>A TritArray representing the same value.</returns>
    public static implicit operator TritArray(int value) => Create(value);

    /// <summary>
    /// Defines an explicit conversion of a TritArray to an int.
    /// </summary>
    /// <param name="array">The TritArray to convert.</param>
    /// <returns>An int representing the same value.</returns>
    public static explicit operator int(TritArray array)
    {
        var bitMask = array.BitMask;
        return (int)TritConverter.ToInt64(array.Negative & bitMask, array.Positive & bitMask);
    }

    /// <summary>
    /// Defines an implicit conversion of a long to a TritArray.
    /// </summary>
    /// <param name="value">The long value to convert.</param>
    /// <returns>A TritArray representing the same value.</returns>
    public static implicit operator TritArray(long value) => Create(value);

    /// <summary>
    /// Defines an implicit conversion of a TritArray to a long.
    /// </summary>
    /// <param name="array">The TritArray to convert.</param>
    /// <returns>A long representing the same value.</returns>
    public static explicit operator long(TritArray array)
    {
        var bitMask = array.BitMask;
        return TritConverter.ToInt64(array.Negative & bitMask, array.Positive & bitMask);
    }
    
    /// <summary>
    /// Defines an implicit conversion of a TritArray to a long.
    /// </summary>
    /// <param name="array">The TritArray to convert.</param>
    /// <returns>A long representing the same value.</returns>
    public static explicit operator Int128(TritArray array)
    {
        var bitMask = array.BitMask;
        return TritConverter.ToInt128(array.Negative & bitMask, array.Positive & bitMask);
    }

    #endregion

    /// <inheritdoc/>   
    public override int GetHashCode() => HashCode.Combine(Negative.GetHashCode(), Positive.GetHashCode());

    /// <inheritdoc/>  
    public override bool Equals(object? obj) => obj is TritArray other && Equals(other);

    /// <inheritdoc/>  
    public bool Equals(TritArray other) => Negative == other.Negative && Positive == other.Positive;

    internal string DebugView() => $"{this} ({this:ter})";

    // ToString implementation
    /// <summary>
    /// Returns a string representation of the TritArray.
    /// </summary>
    public override string ToString() => Formatter.Format(this, null, null);
    /// <summary>
    /// Returns a string representation of the TritArray.
    /// </summary>
    public string ToString(string? format) => Formatter.Format(this, format, null);
    /// <summary>
    /// Returns a string representation of the TritArray.
    /// </summary>
    public string ToString(IFormatProvider? provider) => Formatter.Format(this, null, provider);
    /// <summary>
    /// Returns a string representation of the TritArray.
    /// </summary>
    public string ToString(string? format, IFormatProvider? provider) => Formatter.Format(this, format, provider);
    /// <summary>
    /// Returns a string representation of this instance, formatted balanced ternarily according to the specified format.
    /// </summary>
    public string ToString(ITernaryFormat format) => Formatter.Format((ITritArray)this, format);
}