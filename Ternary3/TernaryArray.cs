// <auto-generated />
#nullable enable
namespace Ternary3;

using Formatting;
using Operators;
using System.Diagnostics;
using System.Numerics;
using TritArrays;

/// <summary>
/// Represents a fixed-size array of 27 trits (ternary digits).
/// </summary>
[DebuggerDisplay("{DebugView()}")]
public struct TernaryArray : ITernaryArray<TernaryArray>
{
    private ulong BitMask => 2UL ^ NumberOfTrits - 1UL;
    internal readonly byte NumberOfTrits;
    internal ulong Positive;
    internal ulong Negative;

    /// <summary>
    /// Represents the minimum value that a TernaryArray can have (all trits set to -1).
    /// </summary>
    public readonly TernaryArray MinValue => new(ulong.MaxValue, 0, 64);

    /// <summary>
    /// Represents the maximum value that a TernaryArray can have (all trits set to 1).
    /// </summary>
    public readonly TernaryArray MaxValue => new(0, ulong.MaxValue, 64);

    /// <summary>
    /// Represents a TernaryArray with all trits set to zero.
    /// </summary>
    public static readonly TernaryArray Zero = new(0,0,0);

    /// <summary>
    /// Initializes a new instance of the TernaryArray struct with all trits set to zero.
    /// </summary>
    public TernaryArray()
    {
    }

    /// <summary>
    /// Initializes a new instance of the TernaryArray struct with the specified negative and positive bits.
    /// </summary>
    /// <param name="negative">The negative bits representing the trits.</param>
    /// <param name="positive">The positive bits representing the trits.</param>
    /// <param name="length">The length of the array.</param>
    internal TernaryArray(ulong negative, ulong positive, byte length)
    {
        Negative = negative;
        Positive = positive;
        NumberOfTrits = length;
    }
    
    /// <summary>
    /// Parses a string representation of a TernaryArray.
    /// </summary>
    /// <param name="value">The string value to parse.</param>
    /// <returns>A TernaryArray representing the parsed value.</returns>
    public static TernaryArray Parse(string value) => Parser.ParseTritArray(value);
    
    /// <summary>
    /// Parses a string representation of a TernaryArray.
    /// </summary>
    /// <param name="value">The string value to parse.</param>
    /// <param name="format">The format to use for parsing.</param>
    /// <returns>A TernaryArray representing the parsed value.</returns>
    public static TernaryArray Parse(string value, ITernaryFormat format) => Parser.ParseTritArray(value, format);
    
    /// <summary>
    /// Parses a string representation of a TernaryArray.
    /// </summary>
    /// <param name="value">The string value to parse.</param>
    /// <param name="options">The options to use for parsing.</param>
    /// <returns>A TernaryArray representing the parsed value.</returns>
    public static TernaryArray Parse(string value, TritParseOptions options) => Parser.ParseTritArray(value, null, options);
    
    /// <summary>
    /// Parses a string representation of a TernaryArray.
    /// </summary>
    /// <param name="value">The string value to parse.</param>
    /// <param name="format">The format to use for parsing.</param>
    /// <param name="options">The options to use for parsing.</param>
    /// <returns>A TernaryArray representing the parsed value.</returns>
    public static TernaryArray Parse(string value, ITernaryFormat format, TritParseOptions options) => Parser.ParseTritArray(value, format, options);

    /// <intheritdoc/>
    public Trit this[int index]
    {
        get => index >= 0 && index < NumberOfTrits
                ? TritConverter.GetTrit(Negative, Positive, index)
                : throw new ArgumentOutOfRangeException(nameof(index), $"Index must be between 0 and {NumberOfTrits - 1}.");
        set
        {
            if (index < 0 || index >= NumberOfTrits)
            {
                throw new ArgumentOutOfRangeException(nameof(index), $"Index must be between 0 and {NumberOfTrits - 1}.");
            }
            TritConverter.SetTrit(ref Negative, ref Positive, index, value);
        }
    }

    /// <intheritdoc/>
    public ITritArray this[Range range]
    {
        get
        {
            Splicer.Splice(Negative, Positive, Length, range, out var negative, out var positive, out var length);
            return new TernaryArray(negative, positive, (byte)length);
        }
    }

    /// <summary>
    /// Gets or sets the trit at the specified index.
    /// </summary>
    /// <param name="index">The zero-based index of the trit to get or set (must be between 0 and 26).</param>
    /// <returns>The trit at the specified index.</returns>
    /// <exception cref="ArgumentOutOfRangeException">Thrown when index is less than 0 or greater than 26.</exception>
    public Trit this[Index index]
    {
        get => index.IsFromEnd ? this[NumberOfTrits - index.Value] : this[index.Value];
        set
        {
            if (index.IsFromEnd)
            {
                this[NumberOfTrits - index.Value] = value;
            }
            else
            {
                this[index.Value] = value;
            }
        }
    }

    /// <summary>
    /// Gets the length of the trit array
    /// </summary>
    public int Length => NumberOfTrits;

    /// <summary>
    /// Applies a unary operation to each trit in the array.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="operation">The unary operation to apply to each trit.</param>
    /// <returns>A new TernaryArray with the operation applied to each trit.</returns>
    public static TernaryArray operator |(TernaryArray array, Func<Trit, Trit> operation)
        => array | new UnaryTritOperator(operation);

    /// <summary>
    /// Applies a lookup table operation to each trit in the array.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="table">The lookup table containing the transformation values.</param>
    /// <returns>A new TernaryArray with the lookup operation applied to each trit.</returns>
    public static TernaryArray operator |(TernaryArray array, Trit[] table)
        => array | new UnaryTritOperator(table);

    /// <summary>
    /// Creates a binary operation context for this array.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="operation">The binary operation to be applied.</param>
    /// <returns>A LookupTritArrayOperator that can be used to apply the operation with another array.</returns>
    public static LookupTritArrayOperator operator |(TernaryArray array, Func<Trit, Trit, Trit> operation)
        => new LookupTritArrayOperator(array, operation);

    /// <summary>
    /// Creates a binary operation context for this array using a lookup table.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="table">The lookup table containing the transformation values.</param>
    /// <returns>A LookupTritArrayOperator that can be used to apply the operation with another array.</returns>
    public static LookupTritArrayOperator operator |(TernaryArray array, BinaryTritOperator table)
        => new LookupTritArrayOperator(array, table);

    /// <summary>
    /// Creates a binary operation context for this array using a 2D lookup table.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="table">The 2D lookup table containing the transformation values.</param>
    /// <returns>A LookupTritArrayOperator that can be used to apply the operation with another array.</returns>
    public static LookupTritArrayOperator operator |(TernaryArray array, Trit[,] table)
        => new LookupTritArrayOperator(array, table);


    /// <summary>
    /// Performs a left bitwise shift on the trit array.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="shift">The number of positions to shift.</param>
    /// <returns>A new TernaryArray with the bits shifted to the left.</returns>
    public static TernaryArray operator <<(TernaryArray array, int shift)
    {
        if (shift == 0) return array;
        if (shift >= array.NumberOfTrits) return Zero;
        var bitMask = array.BitMask;
        if (shift < 0) return new(array.Negative >> -shift, array.Positive >> -shift, array.NumberOfTrits);
        return new((array.Negative << shift) & bitMask, (array.Positive << shift) & bitMask, array.NumberOfTrits);
    }

    /// <summary>
    /// Performs a right bitwise shift on the trit array.
    /// </summary>
    /// <param name="array">The source array.</param>
    /// <param name="shift">The number of positions to shift.</param>
    /// <returns>A new TernaryArray with the bits shifted to the right.</returns>
    public static TernaryArray operator >>(TernaryArray array, int shift)
    {
        if (shift == 0) return array;
        if (shift >= array.NumberOfTrits) return Zero;
        var bitMask = array.BitMask;
        if (shift < 0) return new(array.Negative << -shift, array.Positive << -shift, array.NumberOfTrits);
        return new((array.Negative >> shift) & bitMask, (array.Positive >> shift) & bitMask, array.NumberOfTrits);
    }

    /// <summary>
    /// Adds two TernaryArray values together.
    /// </summary>
    /// <param name="value1">The first value to add.</param>
    /// <param name="value2">The second value to add.</param>
    /// <returns>A new TernaryArray representing the sum of the two values.</returns>
    public static TernaryArray operator +(TernaryArray value1, TernaryArray value2)
    {
        Calculator.AddBalancedTernary(value1.Negative, value1.Positive, value2.Negative, value2.Positive, out var negative, out var positive);
        var length = 64-BitOperations.LeadingZeroCount(negative | positive);
        return new(negative, positive, (byte)length);
    }

    /// <summary>
    /// Subtracts one TernaryArray value from another.
    /// </summary>
    /// <param name="value1">The value to subtract from.</param>
    /// <param name="value2">The value to subtract.</param>
    /// <returns>A new TernaryArray representing the difference between the two values.</returns>
    public static TernaryArray operator -(TernaryArray value1, TernaryArray value2)
    {
        Calculator.AddBalancedTernary(value1.Negative, value1.Positive, value2.Positive, value2.Negative, out var negative, out var positive);
        var length = 64-BitOperations.LeadingZeroCount(negative | positive);
        return new(negative, positive, (byte)length);
    }

    #region Conversion Operators

    /// <summary>
    /// Creates a TernaryArray from an integer value.
    /// </summary>
    /// <param name="value">The integer value to convert.</param>
    /// <returns>A new TernaryArray representing the value in balanced ternary.</returns>
    private static TernaryArray Create(long value)
    {
        TritConverter.To32Trits(value, out var negative, out var positive);
        var length = 64-BitOperations.LeadingZeroCount(negative | positive);
        return new(negative, positive, (byte)length);
    }

    /// <summary>
    /// Defines an implicit conversion of an Int27T to a TernaryArray.
    /// </summary>
    /// <param name="value">The Int27T value to convert.</param>
    /// <returns>A TernaryArray representing the same value.</returns>
    public static implicit operator TernaryArray(Int27T value)
    {
        // Cast to long to get the numeric value instead of trying to access a non-existent Value property
        TritConverter.To32Trits(value, out var negative, out var positive);
        var length = 64-BitOperations.LeadingZeroCount(negative | positive);
        return new(negative, positive, (byte)length);
    }

    /// <summary>
    /// Defines an implicit conversion of a TernaryArray to an Int27T.
    /// </summary>
    /// <param name="array">The TernaryArray to convert.</param>
    /// <returns>An Int27T representing the same value.</returns>
    public static implicit operator Int27T(TernaryArray array) => (Int64)TritConverter.ToInt64(array.Negative, array.Positive);


    /// <summary>
    /// Defines an implicit conversion of an int to a TernaryArray.
    /// </summary>
    /// <param name="value">The int value to convert.</param>
    /// <returns>A TernaryArray representing the same value.</returns>
    public static implicit operator TernaryArray(int value) => Create(value);

    /// <summary>
    /// Defines an explicit conversion of a TernaryArray to an int.
    /// </summary>
    /// <param name="array">The TernaryArray to convert.</param>
    /// <returns>An int representing the same value.</returns>
    public static explicit operator int(TernaryArray array)
    {
        var bitMask = array.BitMask;
        return (int)TritConverter.ToInt64(array.Negative & bitMask, array.Positive & bitMask);
    }

    /// <summary>
    /// Defines an implicit conversion of a long to a TernaryArray.
    /// </summary>
    /// <param name="value">The long value to convert.</param>
    /// <returns>A TernaryArray representing the same value.</returns>
    public static implicit operator TernaryArray(long value) => Create(value);

    /// <summary>
    /// Defines an implicit conversion of a TernaryArray to a long.
    /// </summary>
    /// <param name="array">The TernaryArray to convert.</param>
    /// <returns>A long representing the same value.</returns>
    public static explicit operator long(TernaryArray array)
    {
        var bitMask = array.BitMask;
        return TritConverter.ToInt64(array.Negative & bitMask, array.Positive & bitMask);
    }
    
    /// <summary>
    /// Defines an implicit conversion of a TernaryArray to a long.
    /// </summary>
    /// <param name="array">The TernaryArray to convert.</param>
    /// <returns>A long representing the same value.</returns>
    public static explicit operator Int128(TernaryArray array)
    {
        var bitMask = array.BitMask;
        return TritConverter.ToInt128(array.Negative & bitMask, array.Positive & bitMask);
    }

    #endregion

    /// <inheritdoc/>   
    public override int GetHashCode() => HashCode.Combine(Negative.GetHashCode(), Positive.GetHashCode());

    /// <inheritdoc/>  
    public override bool Equals(object? obj) => obj is TernaryArray other && Equals(other);

    /// <inheritdoc/>  
    public bool Equals(TernaryArray other) => Negative == other.Negative && Positive == other.Positive;

    internal string DebugView() => $"{this} ({this:ter})";

    // ToString implementation
    /// <summary>
    /// Returns a string representation of the TernaryArray.
    /// </summary>
    public override string ToString() => Formatter.Format(this, null, null);
    /// <summary>
    /// Returns a string representation of the TernaryArray.
    /// </summary>
    public string ToString(string? format) => Formatter.Format(this, format, null);
    /// <summary>
    /// Returns a string representation of the TernaryArray.
    /// </summary>
    public string ToString(IFormatProvider? provider) => Formatter.Format(this, null, provider);
    /// <summary>
    /// Returns a string representation of the TernaryArray.
    /// </summary>
    public string ToString(string? format, IFormatProvider? provider) => Formatter.Format(this, format, provider);
    /// <summary>
    /// Returns a string representation of this instance, formatted balanced ternarily according to the specified format.
    /// </summary>
    public string ToString(ITernaryFormat format) => Formatter.Format((ITritArray)this, format);
}