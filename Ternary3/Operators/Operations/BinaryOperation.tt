<#@ template language="C#" hostspecific="True" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Threading" #>
// <auto-generated />
namespace Ternary3.Operators.Operations;

using System;
using System.Numerics;

internal static class BinaryOperation
{
    public static T GetTrits<T>(int index, T n1, T p1, T n2, T p2)
        where T : struct, IBinaryInteger<T>, IMinMaxValue<T>
    {
        return index switch
        {
<#
    for (var i = 0; i < 512; i++)
    {
#>
            <#= i #> => <#= GetExpression(i) #>,  
<#
    }
#>
            _ => throw new ArgumentOutOfRangeException(nameof(index), "Index must be between 0 and 511.")
        };
    }
}

<#
    string GetExpression(int value)
    {
        // Create a BitArray from the value
        BitArray bits = new(9);
        BitArray notbits = new(9);
        var count = 0;
        for (var i = 0; i < 9; i++)
        {
            var bit = ((value >>  i) & 1) == 1;
            bits[i] = bit;
            notbits[i] = !bit;
            if (bit) count++;
        }

        // bits is always 9 bits.
        // order: (T,T), (T,0), (T,1), (0,T), (0,0), (0,1), (1,T), (1,0), (1,1)
        // (corresponding to bits[0] to bits[8])
        // expressions for each bit:
        // bit 0 (T, T) => n1 & n2
        // bit 1 (T, 0) => n1 & ~(p2 | n2)
        // bit 2 (T, 1) => n1 & p2
        // bit 3 (0, T) => ~(p1 | n1) & n2
        // bit 4 (0, 0) => ~(p1 | n1) & ~(p2 | n2)
        // bit 5 (0, 1) => ~(p1 | n1) & p2
        // bit 6 (1, T) => p1 & n2
        // bit 7 (1, 0) => p1 & ~(p2 | n2)
        // bit 8 (1, 1) => p1 & p2

        switch (count)
        {
            case 0:
                return "T.Zero";
            case 1:
                return GetByBits(bits).First();
            case 8:
                return Not(GetByBits(notbits).First());
            case 9:
                return "T.MaxValue";
        }

        var rows = new[]
        {
            new[] { bits[0], bits[1], bits[2] },
            new[] { bits[3], bits[4], bits[5] },
            new[] { bits[6], bits[7], bits[8] }
        };

        var cols = new[]
        {
            new[] { bits[0], bits[3], bits[6] },
            new[] { bits[1], bits[4], bits[7] },
            new[] { bits[2], bits[5], bits[8] }
        };

        var groupings = new[] { rows, cols };

        var all = new bool[2, 3]
        {
            {
                rows[0].All(b => b),
                rows[1].All(b => b),
                rows[2].All(b => b)
            },
            {
                cols[0].All(b => b),
                cols[1].All(b => b),
                cols[2].All(b => b)
            }
        };
        var none = new bool[2, 3]
        {
            {
                rows[0].All(b => !b),
                rows[1].All(b => !b),
                rows[2].All(b => !b)
            },
            {
                cols[0].All(b => !b),
                cols[1].All(b => !b),
                cols[2].All(b => !b)
            }
        };
        bool AreSame(bool[] b1, bool[] b2) => b1[0] == b2[0] && b1[1] == b2[1] && b1[2] == b2[2];
        var duplicate = new[,]
        {
            {
                AreSame(rows[0], rows[1]),
                AreSame(rows[1], rows[2]),
                AreSame(rows[2], rows[0])
            },
            {
                AreSame(cols[0], cols[1]),
                AreSame(cols[1], cols[2]),
                AreSame(cols[2], cols[0])
            }
        };

        // if three rows are the same look at the columns
        for (var group = 0; group < 2; group++)
        {
            if (duplicate[group, 1] && duplicate[group, 2]) return GetByBits2(groupings[group][0], 1-group);
        }

        // if two rows are empty then take the third row AND (column) 
        for (var group = 0; group < 2; group++)
        {
            for (var i = 0; i < 3; i++)
            {
                if (none[group, (i+1)%3] && none[group, (i + 2) % 3])
                {
                    return $"{GetByValue(i, group)} & {GetByBits2(groupings[group][i], 1-group)}";
                }
            }
        }
        
        // if two rows are full then take the third row OR (column)
        for (var group = 0; group < 2; group++)
        {
            for (var i = 0; i < 3; i++)
            {
                if (all[group, (i + 1) % 3] && all[group, (i + 2) % 3])
                {
                    return $"{GetByValue(5-i, group)} | {GetByBits2(groupings[group][i], 1-group)}";
                }
            }
        }
        
        // if two rows are the same
        // in one row is full
        // (or both)
        

        return count > 5
            ? Not(string.Join("|", GetByBits(notbits).Select(p => $"({p})")))
            : string.Join("|", GetByBits(bits).Select(p => $"({p})"));
    }

    IEnumerable<string> GetByBits(BitArray bits)
    {
        if (bits[0]) yield return "n1 & n2";
        if (bits[1]) yield return "n1 & ~(p2 | n2)";
        if (bits[2]) yield return "n1 & p2";
        if (bits[3]) yield return "~(p1 | n1) & n2";
        if (bits[4]) yield return "~(p1 | n1 | p2 | n2)";
        if (bits[5]) yield return "~(p1 | n1) & p2";
        if (bits[6]) yield return "p1 & n2";
        if (bits[7]) yield return "p1 & ~(p2 | n2)";
        if (bits[8]) yield return "p1 & p2";
    }

    string GetByBits2(bool[] b, int g)
    {
        var x = $"{g + 1}";
        return (b[0],b[1],b[2]) switch
        {
            (true, false, false) => $"n{x}",
            (false, true, false) => $"~(p{x} | n{x})",
            (false, false, true) => $"p{x}",
            (true, true, false) => $"~p{x}", 
            (true, false, true) => $"(p{x} | n{x})",
            (false, true, true) => $"~n{x}",
            _  => "?"
            };
    }
    
    string GetByValue(int value, int g)
    {
        var x = $"{g + 1}";
        return value switch
        {
            0 => $"n{x}",
            1 => $"~(p{x} | n{x})",
            2 => $"p{x}",
            3 => $"~p{x}", 
            4 => $"(p{x} | n{x})",
            5 => $"~n{x}",
            _ => "?"
        };
    }

    string Not(string expression) => $"~({expression})";
#>