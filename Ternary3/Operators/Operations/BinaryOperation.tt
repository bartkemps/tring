<#@ template language="C#" hostspecific="True" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Threading" #>
<#@ import namespace="System.Text.RegularExpressions" #>
// <auto-generated />
namespace Ternary3.Operators.Operations;

using System;
using System.Numerics;

internal static class BinaryOperation<T>
    where T : struct, IBinaryInteger<T>, IMinMaxValue<T>
{
    public static T GetTrits(int index, T n1, T p1, T n2, T p2) => Getters[index](n1, p1, n2, p2);

    private static Func<T,T,T,T,T>[] Getters = [
        (n1, p1, n2, p2) => T.Zero,
<#
    for (var i = 1; i < 511; i++)
    {
#>
        (n1, p1, n2, p2) => <#= GetExpression(i) #>,  // <#= Convert.ToString(i, 2) #>
<#
    }
#>
        (n1, p1, n2, p2) => T.MaxValue
    ];
}

<#
    string GetExpression(int value)
    {
        // Create a BitArray from the value
        BitArray bits = new(9);
        BitArray notbits = new(9);
        var count = 0;
        for (var i = 0; i < 9; i++)
        {
            var bit = ((value >>  i) & 1) == 1;
            bits[i] = bit;
            notbits[i] = !bit;
            if (bit) count++;
        }

        switch (count)
        {
            case 1:
                return GetByBits(bits).First();
            case 8:
                return Not(GetByBits(notbits).First());
        }

        var rows = new[]
        {
            new[] { bits[0], bits[1], bits[2] },
            new[] { bits[3], bits[4], bits[5] },
            new[] { bits[6], bits[7], bits[8] }
        };

        var cols = new[]
        {
            new[] { bits[0], bits[3], bits[6] },
            new[] { bits[1], bits[4], bits[7] },
            new[] { bits[2], bits[5], bits[8] }
        };

        var groupings = new[] { rows, cols };

        var all = new bool[2, 3]
        {
            {
                rows[0].All(b => b),
                rows[1].All(b => b),
                rows[2].All(b => b)
            },
            {
                cols[0].All(b => b),
                cols[1].All(b => b),
                cols[2].All(b => b)
            }
        };
        var none = new bool[2, 3]
        {
            {
                rows[0].All(b => !b),
                rows[1].All(b => !b),
                rows[2].All(b => !b)
            },
            {
                cols[0].All(b => !b),
                cols[1].All(b => !b),
                cols[2].All(b => !b)
            }
        };
        bool AreSame(bool[] b1, bool[] b2) => b1[0] == b2[0] && b1[1] == b2[1] && b1[2] == b2[2];
        var duplicate = new[,]
        {
            {
                AreSame(rows[1], rows[2]),
                AreSame(rows[2], rows[0]),
                AreSame(rows[0], rows[1])
            },
            {
                AreSame(cols[1], cols[2]),
                AreSame(cols[2], cols[0]),
                AreSame(cols[0], cols[1])
            }
        };

        // if three rows are the same look at the columns
        for (var group = 0; group < 2; group++)
        {
            if (duplicate[group, 1] && duplicate[group, 2]) return GetByBits2(groupings[group][0], 1-group);
        }

        // if two rows are empty or two rows are full 
        for (var group = 0; group < 2; group++)
        {
            for (var i = 0; i < 3; i++)
            {
                if (none[group, (i+1)%3] && none[group, (i + 2) % 3])
                {
                    return $"{GetByValue(i, group)} & {GetByBits2(groupings[group][i], 1-group)}";
                }
                if (all[group, (i + 1) % 3] && all[group, (i + 2) % 3])
                {
                    return $"{GetByValue(5-i, group)} | {GetByBits2(groupings[group][i], 1-group)}";
                }
            }
        }
        
        // if one row is empty and one is full
        for (var group = 0; group < 2; group++)
        {
            for (var i = 0; i < 3; i++)
            {
                if (all[group, i] && none[group, (i + 1) % 3])
                {
                    return $"{GetByValue(i, group)} | ({GetByValue((i+2)%3, group)} & {GetByBits2(groupings[group][(i + 2) % 3], 1-group)})";
                }
                if (all[group, i] && none[group, (i + 2) % 3])
                {
                    return $"{GetByValue(i, group)} | ({GetByValue((i+1)%3, group)} & {GetByBits2(groupings[group][(i + 1) % 3], 1-group)})";
                }
            }
        }
        
        // if one row is empty
        for (var group = 0; group < 2; group++)
        {
            for (var i = 0; i < 3; i++)
            {
                if (none[group, i])
                {
                    return $"({GetByValue((i+1)%3, group)} & {GetByBits2(groupings[group][(i + 1) % 3], 1-group)}) | ({GetByValue((i+2)%3, group)} & {GetByBits2(groupings[group][(i + 2) % 3], 1-group)})";
                }
            }
        }

        // if one row is full
        for (var group = 0; group < 2; group++)
        {
            for (var i = 0; i < 3; i++)
            {
                if (all[group, i])
                {
                    return $"{GetByValue(i, group)} | ({GetByValue((i + 1) % 3, group)} & {GetByBits2(groupings[group][(i + 1) % 3], 1-group)}) | ({GetByValue((i + 2) % 3, group)} & {GetByBits2(groupings[group][(i + 2) % 3], 1-group)})";
                }
            }
        }
        
        // get the by rows or columns and decide on the shortest expression
        var expression1 = $"({GetByValue(0, 0)} & {GetByBits2(rows[0], 1)}) | ({GetByValue(1, 0)} & {GetByBits2(rows[1], 1)}) | ({GetByValue(2, 0)} & {GetByBits2(rows[2], 1)})";
        var expression2 = $"({GetByValue(0, 1)} & {GetByBits2(cols[0], 0)}) | ({GetByValue(1, 1)} & {GetByBits2(cols[1], 0)}) | ({GetByValue(2, 1)} & {GetByBits2(cols[2], 0)})";
        return Regex.Replace(expression1, "^[!&|]", "").Length
               < Regex.Replace(expression2, "^[!&|]", "").Length
            ? expression1
            : expression2;
    }

    IEnumerable<string> GetByBits(BitArray bits)
    {
        if (bits[0]) yield return "n1 & n2";
        if (bits[1]) yield return "n1 & ~(p2 | n2)";
        if (bits[2]) yield return "n1 & p2";
        if (bits[3]) yield return "~(p1 | n1) & n2";
        if (bits[4]) yield return "~(p1 | n1 | p2 | n2)";
        if (bits[5]) yield return "~(p1 | n1) & p2";
        if (bits[6]) yield return "p1 & n2";
        if (bits[7]) yield return "p1 & ~(p2 | n2)";
        if (bits[8]) yield return "p1 & p2";
    }

    string GetByBits2(bool[] b, int g)
    {
        var x = $"{g + 1}";
        return (b[0],b[1],b[2]) switch
        {
            (true, false, false) => $"n{x}",
            (false, true, false) => $"~(p{x} | n{x})",
            (false, false, true) => $"p{x}",
            (true, true, false) => $"~p{x}", 
            (true, false, true) => $"(p{x} | n{x})",
            (false, true, true) => $"~n{x}",
            _  => "?"
            };
    }
    
    // "5 - value" inverts.
    string GetByValue(int value, int g)
    {
        var x = $"{g + 1}";
        return value switch
        {
            0 => $"n{x}",
            1 => $"~(p{x} | n{x})",
            2 => $"p{x}",
            3 => $"~p{x}", 
            4 => $"(p{x} | n{x})",
            5 => $"~n{x}",
            _ => "?"
        };
    }

    string Not(string expression) => $"~({expression})";
#>