<#@ template debug="false" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>
<#
    // Define the trit array sizes to generate
    var tritArraySizes = new List<(int Trits, string BackingType, string IntBackingType)>
    {
        (3, "Byte", "SByte"),
        (9, "UInt16", "Int16"), 
        (27, "UInt32", "Int64")
    };

    // Loop through each size and generate its file
    foreach (var size in tritArraySizes)
    {
        // Generate the file content
        var fileContent = GenerateTritArrayClass(
            size.Trits,
            size.BackingType,
            size.IntBackingType
        );

        // Determine the output file path
        var outputFilePath = Host.ResolvePath($"TritArray{size.Trits}.cs");

        // Write the content to the file
        File.WriteAllText(outputFilePath, fileContent);
    }
#>
LastGenerated = <#= DateTime.Now.ToString() #>

<#+
// This method generates the code for a TritArrayN class
private string GenerateTritArrayClass(int trits, string backingType, string intBackingType)
{
    return $$"""
           // <auto-generated />
           namespace Ternary3.Numbers;
           
           using Operators;
           using System.Diagnostics;
           using TritArray;
           using TritArrays;
           
           /// <summary>
           /// Represents a fixed-size array of {{trits}} trits (ternary digits).
           /// </summary>
           [DebuggerDisplay("{DebugView()}")]
           public struct TritArray{{trits}} : ITritArray
           {
               private const {{backingType}} BitMask = 0b{{new string('1', trits)}};
               private const int NumberOfTrits = {{trits}};
               internal {{backingType}} Positive;
               internal {{backingType}} Negative;
           
               /// <summary>
               /// Initializes a new instance of the TritArray{{trits}} struct with all trits set to zero.
               /// </summary>
               public TritArray{{trits}}()
               {
               }
           
               private TritArray{{trits}}({{backingType}}Pair trits)
               {
                   Negative = trits.Negative;
                   Positive = trits.Positive;
               }
           
               /// <summary>
               /// Gets or sets the trit at the specified index.
               /// </summary>
               /// <param name="index">The zero-based index of the trit to get or set (must be between 0 and {{trits-1}}).</param>
               /// <returns>The trit at the specified index.</returns>
               /// <exception cref="ArgumentOutOfRangeException">Thrown when index is less than 0 or greater than {{trits-1}}.</exception>
               public Trit this[int index]
               {
                   get => index is >= 0 and < NumberOfTrits 
                           ? TritConverter.GetTrit(Negative, Positive, index)
                           : throw new ArgumentOutOfRangeException(nameof(index), $"Index must be between 0 and {NumberOfTrits-1}.");
                   set
                   {
                       if (index is < 0 or >= NumberOfTrits)
                       {
                           throw new ArgumentOutOfRangeException(nameof(index), $"Index must be between 0 and {NumberOfTrits-1}.");
                       }
                       TritConverter.SetTrit(ref Negative, ref Positive, index, value);
                   }
               }
           
               /// <summary>
               /// Gets the length of the trit array, which is always {{trits}}.
               /// </summary>
               public int Length => NumberOfTrits;
           
               /// <summary>
               /// Applies a unary operation to each trit in the array.
               /// </summary>
               /// <param name="array">The source array.</param>
               /// <param name="operation">The unary operation to apply to each trit.</param>
               /// <returns>A new TritArray{{trits}} with the operation applied to each trit.</returns>
               public static TritArray{{trits}} operator |(TritArray{{trits}} array, Func<Trit, Trit> operation)
                   => new(UnaryOperation.Apply(array.Negative, array.Positive, operation));
           
               /// <summary>
               /// Applies a lookup table operation to each trit in the array.
               /// </summary>
               /// <param name="array">The source array.</param>
               /// <param name="table">The lookup table containing the transformation values.</param>
               /// <returns>A new TritArray{{trits}} with the lookup operation applied to each trit.</returns>
               public static TritArray{{trits}} operator |(TritArray{{trits}} array, Trit[] table)
                   => new(UnaryOperation.Apply(array.Negative, array.Positive, table));
           
               /// <summary>
               /// Creates a binary operation context for this array.
               /// </summary>
               /// <param name="array">The source array.</param>
               /// <param name="operation">The binary operation to be applied.</param>
               /// <returns>A LookupTritArray{{trits}}Operator that can be used to apply the operation with another array.</returns>
               public static LookupTritArray{{trits}}Operator operator |(TritArray{{trits}} array, Func<Trit, Trit, Trit> operation)
                   => new LookupTritArray{{trits}}Operator(array, operation);
           
               public static LookupTritArray{{trits}}Operator operator |(TritArray{{trits}} array, TritLookupTable table)
                   => new LookupTritArray{{trits}}Operator(array, table);
           
               public static LookupTritArray{{trits}}Operator operator |(TritArray{{trits}} array, Trit[,] table)
                   => new LookupTritArray{{trits}}Operator(array, table);
           
           
               /// <summary>
               /// Performs a left bitwise shift on the trit array.
               /// </summary>
               /// <param name="array">The source array.</param>
               /// <param name="shift">The number of positions to shift.</param>
               /// <returns>A new TritArray{{trits}} with the bits shifted to the left.</returns>
               public static TritArray{{trits}} operator <<(TritArray{{trits}} array, int shift)
               {
                   return shift switch
                   {
                       >= NumberOfTrits => new(),
                       < 0 => array >> -shift,
                       _ => new() { Positive = ({{backingType}})((array.Positive << shift) & BitMask), Negative = ({{backingType}})((array.Negative << shift) & BitMask) }
                   };
               }
           
               /// <summary>
               /// Performs a right bitwise shift on the trit array.
               /// </summary>
               /// <param name="array">The source array.</param>
               /// <param name="shift">The number of positions to shift.</param>
               /// <returns>A new TritArray{{trits}} with the bits shifted to the right.</returns>
               public static TritArray{{trits}} operator >> (TritArray{{trits}} array, int shift)
               {
                   return shift switch
                   {
                       >= NumberOfTrits => new(),
                       < 0 => array << -shift,
                       _ => new() { Positive = ({{backingType}})(array.Positive >> shift), Negative = ({{backingType}})(array.Negative >> shift) }
                   };
               }
           
               /// <summary>
               /// Adds two TritArray{{trits}} values together.
               /// </summary>
               /// <param name="value1">The first value to add.</param>
               /// <param name="value2">The second value to add.</param>
               /// <returns>A new TritArray{{trits}} representing the sum of the two values.</returns>
               public static TritArray{{trits}} operator +(TritArray{{trits}} value1, TritArray{{trits}} value2)
               {
                   Calculator.AddBalancedTernary(value1.Negative, value1.Positive, value2.Negative, value2.Positive, out var negative, out var positive);
                   return new() { Negative = ({{backingType}})negative, Positive = ({{backingType}})positive };
               }
           
               /// <summary>
               /// Subtracts one TritArray{{trits}} value from another.
               /// </summary>
               /// <param name="value1">The value to subtract from.</param>
               /// <param name="value2">The value to subtract.</param>
               /// <returns>A new TritArray{{trits}} representing the difference between the two values.</returns>
               public static TritArray{{trits}} operator -(TritArray{{trits}} value1, TritArray{{trits}} value2)
               {
                   Calculator.AddBalancedTernary(value1.Negative, value1.Positive, value2.Positive, value2.Negative, out var negative, out var positive);
                   return new() { Negative = ({{backingType}})negative, Positive = ({{backingType}})positive };
               }
           
               /// <summary>
               /// Defines an implicit conversion of an Int{{trits}}T to a TritArray{{trits}}.
               /// </summary>
               /// <param name="value">The Int{{trits}}T value to convert.</param>
               /// <returns>A TritArray{{trits}} representing the same value.</returns>
               public static implicit operator TritArray{{trits}}(Int{{trits}}T value)
               {
                   // Cast to long to get the numeric value instead of trying to access a non-existent Value property
                   TritConverter.ConvertTo32Trits(value, out var negative, out var positive);
                   return new() { Negative = ({{backingType}})negative, Positive = ({{backingType}})positive };
               }
           
               /// <summary>
               /// Defines an implicit conversion of a TritArray{{trits}} to an Int{{trits}}T.
               /// </summary>
               /// <param name="array">The TritArray{{trits}} to convert.</param>
               /// <returns>An Int{{trits}}T representing the same value.</returns>
               public static implicit operator Int{{trits}}T(TritArray{{trits}} array) => ({{intBackingType}})TritConverter.TritsToInt{{(intBackingType=="Int64"?"64":"32")}}(array.Negative, array.Positive);
           
               internal string DebugView() => ToString();
           
               public override string ToString() => TritConverter.FormatTrits(Negative, Positive, NumberOfTrits);
           }
           """;
}
#>
