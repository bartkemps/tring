<#@ template debug="false" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>
<#@ import namespace="System.Linq" #>
<#
    // Define the trit array sizes to generate operators for
    var tritArraySizes = new List<(int Trits, string BackingType, string[] types)>
    {
        (3, "Byte",["SByte"]),
        (9, "UInt16",["Int16"]), 
        (27, "UInt32",["Int32","Int64"])
    };

    // Loop through each size and generate its file
    foreach (var (size, backingType, types) in tritArraySizes)
    {
        // Generate the file content
        var fileContent = GenerateLookupTritArrayOperator(size, backingType, types);

        // Determine the output file path
        var outputFilePath = Host.ResolvePath($"LookupTritArray{size}Operator.cs");

        // Write the content to the file
        File.WriteAllText(outputFilePath, fileContent);
    }
#>
LastGenerated = <#= DateTime.Now.ToString() #>

<#+
// This method generates the code for a LookupTritArrayOperator class
private string GenerateLookupTritArrayOperator(int tritArraySize, string backingType, string[] types)
{
    return $$"""
           // <auto-generated />
           namespace Ternary3.Numbers;
           
           using Operators;
           using Operators.Operations;
           using TritArrays;
           
           public readonly struct LookupTritArray{{tritArraySize}}Operator
           {
               private readonly TritArray{{tritArraySize}} trits;
               private readonly BinaryOperationBuilder<{{backingType}}> builder;
           
               internal LookupTritArray{{tritArraySize}}Operator(TritArray{{tritArraySize}} trits, TritLookupTable table)
               {
                   this.trits = trits;
                   this.builder = new(table);
               }
           
               internal LookupTritArray{{tritArraySize}}Operator(TritArray{{tritArraySize}} trits, Trit[,] table)
                   : this(trits, new TritLookupTable(table))
               {
               }
           
               internal LookupTritArray{{tritArraySize}}Operator(TritArray{{tritArraySize}} trits, ReadOnlySpan<Trit> table)
                   : this(trits, new TritLookupTable(table))
               {
               }
           
               internal LookupTritArray{{tritArraySize}}Operator(TritArray{{tritArraySize}} trits, Func<Trit, Trit, Trit> operation)
                   : this(trits, new TritLookupTable(operation))
               {
               }
           
               public static TritArray{{tritArraySize}} operator |(LookupTritArray{{tritArraySize}}Operator left, TritArray{{tritArraySize}} right)
               {
                   left.builder.Build()(left.trits.Negative, left.trits.Positive, right.Negative, right.Positive, out var negative, out var positive);
                   return new(negative, positive);
               }
               
               public static TritArray{{tritArraySize}} operator |(LookupTritArray{{tritArraySize}}Operator left, Int{{tritArraySize}}T right)
               {
                   var tritArray = (TritArray{{tritArraySize}})right;
                   left.builder.Build()(left.trits.Negative, left.trits.Positive, tritArray.Negative, tritArray.Positive, out var negative, out var positive);
                   return new(negative, positive);
               }
               {{string.Join("\r\n", types.Select(type => PipeToTypeOperator(tritArraySize, backingType, type)))}}
           }
           """;
}

private string PipeToTypeOperator(int tritArraySize, string backingType, string type)
{
    return $$"""
           
            public static TritArray{{tritArraySize}} operator |(LookupTritArray{{tritArraySize}}Operator left, {{type}} right)
            {
                TritConverter.ConvertTo32Trits(right, out var rightNegative, out var rightPositive);
                left.builder.Build()(left.trits.Negative, left.trits.Positive, ({{backingType}})rightNegative, ({{backingType}})rightPositive, out var negative, out var positive);
                return new(negative, positive);
            }
        """;
}
#>
