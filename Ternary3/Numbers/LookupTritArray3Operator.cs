// <auto-generated />
namespace Ternary3.Numbers;

using Operators;
using Operators.Operations;
using TritArrays;

public readonly struct LookupTritArray3Operator
{
    private readonly TritArray3 trits;
    private readonly BinaryOperationBuilder<Byte> builder;

    internal LookupTritArray3Operator(TritArray3 trits, TritLookupTable table)
    {
        this.trits = trits;
        this.builder = new(table);
    }

    internal LookupTritArray3Operator(TritArray3 trits, Trit[,] table)
        : this(trits, new TritLookupTable(table))
    {
    }

    internal LookupTritArray3Operator(TritArray3 trits, ReadOnlySpan<Trit> table)
        : this(trits, new TritLookupTable(table))
    {
    }

    internal LookupTritArray3Operator(TritArray3 trits, Func<Trit, Trit, Trit> operation)
        : this(trits, new TritLookupTable(operation))
    {
    }

    public static TritArray3 operator |(LookupTritArray3Operator left, TritArray3 right)
    {
        left.builder.Build()(left.trits.Negative, left.trits.Positive, right.Negative, right.Positive, out var negative, out var positive);
        return new() { Negative = negative, Positive = positive };
    }
    
    public static TritArray3 operator |(LookupTritArray3Operator left, Int3T right)
    {
        var tritArray = (TritArray3)right;
        left.builder.Build()(left.trits.Negative, left.trits.Positive, tritArray.Negative, tritArray.Positive, out var negative, out var positive);
        return new() { Negative = negative, Positive = positive };
    }
       
    public static TritArray3 operator |(LookupTritArray3Operator left, SByte right)
    {
        TritConverter.ConvertTo32Trits(right, out var rightNegative, out var rightPositive);
        left.builder.Build()(left.trits.Negative, left.trits.Positive, (Byte)rightNegative, (Byte)rightPositive, out var negative, out var positive);
        return new() { Negative = negative, Positive = positive };
    }
}