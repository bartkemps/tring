<#@ template debug="false" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>
<#@ import namespace="System.Threading" #>
<#
    // Define the ternary number types to generate
            var ternaryTypes = new List<(string BackingType, int Trits, long BackingTypeMaxValue)>
            {
                ("SByte",3, sbyte.MaxValue),
                // ("SByte", 5, sbyte.MaxValue),
                ("Int16", 9, short.MaxValue),
                // ("Int16", 10, short.MaxValue),
                // ("Int32", 20, int.MaxValue),
                ("Int64", 27, long.MaxValue),
                // ("Int64", 40, long.MaxValue),
            };

            // Loop through each type and generate its file
            foreach (var type in ternaryTypes)
            {
                // Generate the file content
                var fileContent = GenerateTernaryNumberClass(
                    type.BackingType,
                    type.Trits,
                    type.BackingTypeMaxValue
                    );

                // Determine the output file path
                var outputFilePath = Host.ResolvePath($"Int{type.Trits}T.cs");

                // Write the content to the file
                File.WriteAllText(outputFilePath, fileContent);
            }
#>
LastGenerated = <#= DateTime.Now.ToString() #>

<#+
    public static long HalfPow3(long exponent)
    {
        long result = 1;
        while (--exponent > 0)
        {
            result *= 3;
        }
        return 1 + 3 * (result >>  1);
    }

// This method generates the code for a single ternary number struct
    private string GenerateTernaryNumberClass(string backingType, int trits, long backingTypeMaxValue)
    {
        var name = $"Int{trits}T";
        var maxValueConstant = HalfPow3(trits);
        // Check if MaxValueConstant is potentially too big for uint
        var isTooLargeForUint32 = maxValueConstant > uint.MaxValue;
        var useLong = backingType == "Int64";
        var calcType = useLong ? "Int64" : "Int32";

        return $$"""
           // <auto-generated />
           #nullable enable
           
           namespace Ternary3.Numbers;
           
           using Integers;
           using Operators;
           using Operators.Operations;
           using System.CodeDom.Compiler;
           using System.Globalization;
           using System.Numerics;
           using System.Diagnostics.CodeAnalysis;
           
           /// <summary>
           /// Represents a {{trits}}-trit  signed integer, modeled after the <see cref="{{backingType}}"/> type.
           /// </summary>
           [GeneratedCode("IntT.tt", null)]
           public readonly partial struct {{name}} : ITernaryInteger<{{name}}>
           {
               private readonly {{backingType}} value;
           
               /// <summary>
               ///  Represents the maximum value of a <see cref="{{name}}"/>, expressed as a <see cref="{{backingType}}"/> This field is constant.
               /// </summary>
               public const {{backingType}} MaxValueConstant = {{maxValueConstant}};
           
               /// <summary>
               /// Represents the minimum value of a <see cref="{{name}}"/>, expressed as a <see cref="{{backingType}}"/> This field is constant.
               /// </summary>
               public const {{backingType}} MinValueConstant = {{-maxValueConstant}};
           
               /// <summary>
               /// Represents the largest possible value of a <see cref="{{name}}"/>. This field is constant.
               /// </summary>
               public static readonly {{name}} MaxValue = new(MaxValueConstant);
           
               /// <summary>
               /// Represents the smallest possible value of a <see cref="{{name}}"/>. This field is constant.
               /// </summary>
               public static readonly {{name}} MinValue = new(MinValueConstant);
           
               private {{name}}({{backingType}} value) => this.value = value;
               
                {{ string.Join("\r\n     ", CreateCreateMethods(name, backingType)) }}

                {{ string.Join("\r\n     ", CreateOperators(name, backingType)) }}
           
               /// <summary>
               /// Returns a value indicating whether this instance is equal to a specified object.
               /// </summary>
               /// <param name="obj">An object to compare with this instance.</param>
               /// <returns>
               /// <see langword="true"/> if <paramref name="obj"/> is an instance of <see cref="{{name}}"/> or a compatible numeric type
               /// and equals the value of this instance; otherwise, <see langword="false"/>.
               /// </returns>
               public override bool Equals(object? obj)
               {
                   switch (obj)
                   {
                       case null: return false;
                       case {{name}} other: return value == other.value;
                       case int typed: return value == typed;
                       case long int64: return value == int64;
                       case short int16: return value == int16;
                       case byte byteVal: return value == byteVal;
                       case sbyte sbyteVal: return value == sbyteVal;
                       case uint uint32: return value == uint32;
                       case ulong uint64: return value == ({{backingType}})uint64;
                       case ushort uint16: return value == uint16;
                       case float singleValue: return singleValue.Equals(value);
                       case double doubleValue: return doubleValue.Equals(value);
                       case decimal decimalValue: return decimalValue.Equals(value);
                       case char charVal: return value == charVal;
                       case IConvertible conv:
                           try
                           {
                               // ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
                               switch (conv.GetTypeCode())
                               {
                                   case TypeCode.Int16: return value == conv.ToInt16(null);
                                   case TypeCode.UInt16: return value == conv.ToUInt16(null);
                                   case TypeCode.Int32: return value == conv.ToInt32(null);
                                   case TypeCode.UInt32: return value == conv.ToUInt32(null);
                                   case TypeCode.Int64: return value == conv.ToInt64(null);
                                   case TypeCode.UInt64: return value == ({{backingType}})conv.ToUInt64(null);
                                   case TypeCode.Byte: return value == conv.ToByte(null);
                                   case TypeCode.SByte: return value == conv.ToSByte(null);
                                   case TypeCode.Single: return conv.ToSingle(null).Equals(value);
                                   case TypeCode.Double: return conv.ToDouble(null).Equals(value);
                                   case TypeCode.Decimal: return conv.ToDecimal(null).Equals(value);
                               }
                           }
                           catch
                           {
                               return false;
                           }
           
                           break;
                   }
           
                   return obj.Equals(value);
               }
           
               /// <summary>
               /// Returns a value indicating whether this instance is equal to a specified <see cref="{{name}}"/> value.
               /// </summary>
               /// <param name="other">A <see cref="{{name}}"/> value to compare to this instance.</param>
               /// <returns><see langword="true"/> if <paramref name="other"/> has the same value as this instance; otherwise, <see langword="false"/>.</returns>
               public bool Equals({{name}} other) => value == other.value;
           
               /// <summary>
               /// Returns a value indicating whether this instance is equal to a specified <see cref="{{backingType}}"/> value.
               /// </summary>
               /// <param name="other">A <see cref="{{backingType}}"/> value to compare to this instance.</param>
               /// <returns><see langword="true"/> if <paramref name="other"/> has the same value as this instance; otherwise, <see langword="false"/>.</returns>
               public bool Equals({{backingType}} other) => value == other;
           
               /// <summary>
               /// Returns the hash code for this instance.
               /// </summary>
               /// <returns>A 32-bit signed integer hash code.</returns>
               public override int GetHashCode() => value.GetHashCode();
           
               #region Equality Operators
           
               /// <summary>
               /// Returns a value indicating whether two <see cref="{{name}}"/> instances are equal.
               /// </summary>
               /// <param name="left">The first instance to compare.</param>
               /// <param name="right">The second instance to compare.</param>
               /// <returns><see langword="true"/> if the values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <see langword="false"/>.</returns>
               public static bool operator ==(IConvertible left, {{name}} right) => right.Equals(left);
           
               /// <summary>
               /// Returns a value indicating whether two <see cref="{{name}}"/> instances are not equal.
               /// </summary>
               /// <param name="left">The first instance to compare.</param>
               /// <param name="right">The second instance to compare.</param>
               /// <returns><see langword="true"/> if the values of <paramref name="left"/> and <paramref name="right"/> are not equal; otherwise, <see langword="false"/>.</returns>
               public static bool operator !=(IConvertible left, {{name}} right) => !right.Equals(left);
           
               /// <summary>
               /// Returns a value indicating whether two <see cref="{{name}}"/> instances are equal.
               /// </summary>
               /// <param name="left">The first instance to compare.</param>
               /// <param name="right">The second instance to compare.</param>
               /// <returns><see langword="true"/> if the values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <see langword="false"/>.</returns>
               public static bool operator ==({{name}} left, IConvertible right) => left.Equals(right);
           
               /// <summary>
               /// Returns a value indicating whether two <see cref="{{name}}"/> instances are not equal.
               /// </summary>
               /// <param name="left">The first instance to compare.</param>
               /// <param name="right">The second instance to compare.</param>
               /// <returns><see langword="true"/> if the values of <paramref name="left"/> and <paramref name="right"/> are not equal; otherwise, <see langword="false"/>.</returns>
               public static bool operator !=({{name}} left, IConvertible right) => !left.Equals(right);
           
               /// <summary>
               /// Returns a value indicating whether two <see cref="{{name}}"/> instances are equal.
               /// </summary>
               /// <param name="left">The first instance to compare.</param>
               /// <param name="right">The second instance to compare.</param>
               /// <returns><see langword="true"/> if the values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <see langword="false"/>.</returns>
               public static bool operator ==({{name}} left, {{name}} right) => left.value == right.value;
           
               /// <summary>
               /// Returns a value indicating whether two <see cref="{{name}}"/> instances are not equal.
               /// </summary>
               /// <param name="left">The first instance to compare.</param>
               /// <param name="right">The second instance to compare.</param>
               /// <returns><see langword="true"/> if the values of <paramref name="left"/> and <paramref name="right"/> are not equal; otherwise, <see langword="false"/>.</returns>
               public static bool operator !=({{name}} left, {{name}} right) => left.value != right.value;
           
               #endregion
           
               #region Arithmetic Operators
               {{GenerateArithmeticOperators(name, backingType)}}
               #endregion
               
               #region Comparison Operators
           
               // Comparison operators with {{name}}
               public static bool operator >({{name}} left, {{name}} right) => left.value > right.value;
               public static bool operator <({{name}} left, {{name}} right) => left.value < right.value;
               public static bool operator >=({{name}} left, {{name}} right) => left.value >= right.value;
               public static bool operator <=({{name}} left, {{name}} right) => left.value <= right.value;
               {{GenerateComparisonOperators(name, "sbyte", backingType)}}
               {{GenerateComparisonOperators(name, "byte", backingType)}}
               {{GenerateComparisonOperators(name, "int", backingType)}}
               {{GenerateComparisonOperators(name, "uint", backingType)}}
               {{GenerateComparisonOperators(name, "short", backingType)}}
               {{GenerateComparisonOperators(name, "ushort", backingType)}}
               {{GenerateComparisonOperators(name, "long", backingType)}}
               {{GenerateComparisonOperators(name, "ulong", backingType)}}
                {{GenerateComparisonOperators(name, "float", backingType)}}
                {{GenerateComparisonOperators(name, "double", backingType)}}
                {{GenerateComparisonOperators(name, "decimal", backingType)}}
                {{GenerateComparisonOperators(name, "IComparable", backingType)}}
           
               #endregion
           
               // ToString implementation
               public override string ToString() => value.ToString();
               public string ToString(string? format) => value.ToString(format);
               public string ToString(IFormatProvider? provider) => value.ToString(provider);
               public string ToString(string? format, IFormatProvider? provider) => value.ToString(format, provider);
           
               // Parsing methods
           
               /// <summary>
               /// Converts the string representation of a number to its <see cref="{{name}}"/> equivalent.
               /// </summary>
               /// <param name="s">A string containing a number to convert.</param>
               /// <returns>A <see cref="{{name}}"/> equivalent to the number contained in <paramref name="s"/>.</returns>
               /// <exception cref="ArgumentNullException"><paramref name="s"/> is <see langword="null"/>.</exception>
               /// <exception cref="FormatException"><paramref name="s"/> is not in the correct format.</exception>
               /// <exception cref="OverflowException"><paramref name="s"/> represents a number less than <see cref="{{name}}.MinValue"/> or greater than <see cref="{{name}}.MaxValue"/>.</exception>
               public static {{name}} Parse(string s) => Create({{backingType}}.Parse(s));
           
               /// <summary>
               /// Converts the string representation of a number in a specified style to its <see cref="{{name}}"/> equivalent.
               /// </summary>
               /// <param name="s">A string containing a number to convert.</param>
               /// <param name="style">A bitwise combination of enumeration values that indicate the style elements that can be present in <paramref name="s"/>.</param>
               /// <returns>A <see cref="{{name}}"/> equivalent to the number contained in <paramref name="s"/>.</returns>
               /// <exception cref="ArgumentNullException"><paramref name="s"/> is <see langword="null"/>.</exception>
               /// <exception cref="ArgumentException"><paramref name="style"/> is not a <see cref="NumberStyles"/> value or <paramref name="style"/> includes the <see cref="NumberStyles.AllowHexSpecifier"/> value.</exception>
               /// <exception cref="FormatException"><paramref name="s"/> is not in a format compliant with <paramref name="style"/>.</exception>
               /// <exception cref="OverflowException"><paramref name="s"/> represents a number less than <see cref="{{name}}.MinValue"/> or greater than <see cref="{{name}}.MaxValue"/>.</exception>
               public static {{name}} Parse(string s, NumberStyles style) => Create({{backingType}}.Parse(s, style));
           
               /// <summary>
               /// Tries to convert the string representation of a number to its <see cref="{{name}}"/> equivalent, and returns a value that indicates whether the conversion succeeded.
               /// </summary>
               /// <param name="s">A string containing a number to convert.</param>
               /// <param name="result">When this method returns, contains the <see cref="{{name}}"/> value equivalent to the number contained in <paramref name="s"/> if the conversion succeeded, or zero if the conversion failed. This parameter is passed uninitialized.</param>
               /// <returns><see langword="true"/> if <paramref name="s"/> was converted successfully; otherwise, <see langword="false"/>.</returns>
               public static bool TryParse(string? s, out {{name}} result)
               {
                   bool success = {{backingType}}.TryParse(s, out {{backingType}} value);
                   result = new {{name}}(value);
                   return success;
               }
           
               /// <summary>
               /// Compares this instance to a specified object and returns an indication of their relative values.
               /// </summary>
               /// <param name="obj">An object to compare, or <see langword="null"/>.</param>
               /// <returns>
               /// A signed number indicating the relative values of this instance and <paramref name="obj"/>.
               /// Return Value Description:
               /// Less than zero: This instance is less than <paramref name="obj"/>.
               /// Zero: This instance is equal to <paramref name="obj"/>.
               /// Greater than zero: This instance is greater than <paramref name="obj"/> or <paramref name="obj"/> is <see langword="null"/>.
               /// </returns>
               /// <exception cref="ArgumentException"><paramref name="obj"/> is not a <see cref="{{name}}"/> or a type that can be converted to an integer.</exception>
               public int CompareTo(object? obj)
               {
                   if (obj == null) return 1;
                   if (obj is {{name}} other) return CompareTo(other);
           
                   // For large numeric types that exceed {{name}}'s range, return -1 if greater than MaxValue, 1 if less than MinValue
                   try
                   {
                       if (obj is {{backingType}} typed) return value.CompareTo(typed);
                       if (obj is long int64)
                       {
                           return int64 switch
                           {
                               > MaxValueConstant => -1,
                               < MinValueConstant => 1,
                               _ => value.CompareTo(({{backingType}})int64)
                           };
                       }
           
                       if (obj is uint uint32)
                       {
                           return {{(isTooLargeForUint32
                               ? $"value.CompareTo(({backingType})uint32);"
                               : $"uint32 > MaxValueConstant ? -1 : value.CompareTo(({backingType})uint32);")}}
                       }
           
                       if (obj is ulong uint64)
                       {
                           return uint64 > (long)MaxValueConstant ? -1 : value.CompareTo(({{backingType}})uint64);
                       }
           
                       if (obj is short int16) return value.CompareTo(int16);
                       if (obj is ushort uint16) return value.CompareTo(uint16);
                       if (obj is byte byteVal) return value.CompareTo(byteVal);
                       if (obj is sbyte sbyteVal) return value.CompareTo(sbyteVal);
                       if (obj is float singleValue)
                       {
                           return singleValue switch
                           {
                               > MaxValueConstant => -1,
                               < MinValueConstant => 1,
                               _ => value.CompareTo(({{backingType}})singleValue)
                           };
                       }
           
                       if (obj is double doubleValue)
                       {
                           return doubleValue switch
                           {
                               > MaxValueConstant => -1,
                               < MinValueConstant => 1,
                               _ => value.CompareTo(({{backingType}})doubleValue)
                           };
                       }
           
                       if (obj is decimal decimalValue)
                       {
                           return decimalValue switch
                           {
                               > MaxValueConstant => -1,
                               < MinValueConstant => 1,
                               _ => value.CompareTo(({{backingType}})decimalValue)
                           };
                       }
           
                       if (obj is IConvertible convertible)
                       {
                           switch (convertible.GetTypeCode())
                           {
                               case TypeCode.Int16:
                               case TypeCode.UInt16:
                               case TypeCode.Byte:
                               case TypeCode.SByte:
                                   return value.CompareTo(convertible.ToInt32(null));
                               case TypeCode.Int32:
                                   return value.CompareTo(convertible.ToInt32(null));
                               case TypeCode.UInt32:
                                   var uint32Value = convertible.ToUInt32(null);
                                   {{(isTooLargeForUint32 ? "" : "if (uint32Value > MaxValueConstant) return -1;")}}
                                   return value.CompareTo(({{backingType}})uint32Value);
                               case TypeCode.Int64:
                                   var int64Value = convertible.ToInt64(null);
                                   if (int64Value > MaxValueConstant) return -1;
                                   if (int64Value < MinValueConstant) return 1;
                                   return value.CompareTo(({{backingType}})(int64Value));
                               case TypeCode.UInt64:
                                   var uint64Value = convertible.ToUInt64(null);
                                   if (uint64Value > (long)MaxValueConstant) return -1;
                                   return value.CompareTo(({{backingType}})uint64Value);
                               case TypeCode.Single:
                                   var singleVal = convertible.ToSingle(null);
                                   if (singleVal > MaxValueConstant) return -1;
                                   if (singleVal < MinValueConstant) return 1;
                                   return value.CompareTo(({{backingType}})singleVal);
                               case TypeCode.Double:
                                   var doubleVal = convertible.ToDouble(null);
                                   if (doubleVal > MaxValueConstant) return -1;
                                   if (doubleVal < MinValueConstant) return 1;
                                   return value.CompareTo(({{backingType}})doubleVal);
                               case TypeCode.Decimal:
                                   var decimalVal = convertible.ToDecimal(null);
                                   if (decimalVal > MaxValueConstant) return -1;
                                   if (decimalVal < MinValueConstant) return 1;
                                   return value.CompareTo(({{backingType}})decimalVal);
                           }
                       }
                   }
                   catch (OverflowException)
                   {
                       // If conversion fails due to overflow, we can assume the value is outside our range
                       return -1;
                   }
           
                   throw new ArgumentException("Object is not a valid type for comparison", nameof(obj));
               }
           
               /// <summary>
               /// Compares this instance to a specified <see cref="{{name}}"/> object and returns an indication of their relative values.
               /// </summary>
               /// <param name="other">An <see cref="{{name}}"/> object to compare.</param>
               /// <returns>
               /// A signed number indicating the relative values of this instance and <paramref name="other"/>.
               /// Return Value Description:
               /// Less than zero: This instance is less than <paramref name="other"/>.
               /// Zero: This instance is equal to <paramref name="other"/>.
               /// Greater than zero: This instance is greater than <paramref name="other"/>.
               /// </returns>
               public int CompareTo({{name}} other) => value.CompareTo(other.value);
           
               #region IConvertible Implementation
           
               public TypeCode GetTypeCode() => TypeCode.Int32;
           
               bool IConvertible.ToBoolean(IFormatProvider? provider) => value != 0;
               char IConvertible.ToChar(IFormatProvider? provider) => Convert.ToChar(value);
               sbyte IConvertible.ToSByte(IFormatProvider? provider) => Convert.ToSByte(value);
               byte IConvertible.ToByte(IFormatProvider? provider) => Convert.ToByte(value);
               short IConvertible.ToInt16(IFormatProvider? provider) => Convert.ToInt16(value);
               ushort IConvertible.ToUInt16(IFormatProvider? provider) => Convert.ToUInt16(value);
               int IConvertible.ToInt32(IFormatProvider? provider) => Convert.ToInt32(value);
               uint IConvertible.ToUInt32(IFormatProvider? provider) => Convert.ToUInt32(value);
               long IConvertible.ToInt64(IFormatProvider? provider) => Convert.ToInt64(value);
               ulong IConvertible.ToUInt64(IFormatProvider? provider) => Convert.ToUInt64(value);
               float IConvertible.ToSingle(IFormatProvider? provider) => Convert.ToSingle(value);
               double IConvertible.ToDouble(IFormatProvider? provider) => Convert.ToDouble(value);
               decimal IConvertible.ToDecimal(IFormatProvider? provider) => Convert.ToDecimal(value);
               DateTime IConvertible.ToDateTime(IFormatProvider? provider) => throw new InvalidCastException();
               string IConvertible.ToString(IFormatProvider? provider) => value.ToString(provider);
           
               object IConvertible.ToType(Type conversionType, IFormatProvider? provider) =>
                   Convert.ChangeType(value, conversionType, provider);
           
               #endregion
           
               #region IUtf8SpanFormattable Implementation
           
               bool IUtf8SpanFormattable.TryFormat(Span<byte> utf8Destination, out int bytesWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
               {
                   if (!value.TryFormat(stackalloc char[32], out int charsWritten, format, provider))
                   {
                       bytesWritten = 0;
                       return false;
                   }
           
                   // Get UTF8 byte count for the character length
                   var byteCount = System.Text.Encoding.UTF8.GetMaxByteCount(charsWritten);
           
                   if (utf8Destination.Length < byteCount)
                   {
                       bytesWritten = 0;
                       return false;
                   }
           
                   // Convert to string since we can't go directly from ReadOnlySpan<char> to UTF8
                   var str = value.ToString(format.ToString(), provider);
                   bytesWritten = System.Text.Encoding.UTF8.GetBytes(str, utf8Destination);
                   return true;
               }
           
               #endregion
           
               #region IIncrementOperators/IDecrementOperators Implementation
           
               public static {{name}} operator ++({{name}} value) => Create(value.value + 1);
               public static {{name}} operator --({{name}} value) => Create(value.value - 1);
           
               #endregion
           
               static bool IEqualityOperators<{{name}}, {{name}}, bool>.operator ==({{name}} left, {{name}} right) => left.value == right.value;
               static bool IEqualityOperators<{{name}}, {{name}}, bool>.operator !=({{name}} left, {{name}} right) => left.value != right.value;
           
               #region Binary Operations

               {{GenerateBinaryOperations(name, backingType)}}

               #endregion
           
               #region Interface Static Members
           
               static {{name}} ISignedNumber<{{name}}>.NegativeOne => new(-1);
               static {{name}} INumberBase<{{name}}>.One => new(1);
               static {{name}} INumberBase<{{name}}>.Zero => new(0);
               static {{name}} IAdditiveIdentity<{{name}}, {{name}}>.AdditiveIdentity => new(0);
               static {{name}} IMultiplicativeIdentity<{{name}}, {{name}}>.MultiplicativeIdentity => new(1);
           
               static bool INumberBase<{{name}}>.IsCanonical({{name}} value) => true;
               static bool INumberBase<{{name}}>.IsComplexNumber({{name}} value) => false;
               static bool INumberBase<{{name}}>.IsEvenInteger({{name}} value) => value.value % 2 == 0;
               static bool INumberBase<{{name}}>.IsFinite({{name}} value) => true;
               static bool INumberBase<{{name}}>.IsImaginaryNumber({{name}} value) => false;
               static bool INumberBase<{{name}}>.IsInfinity({{name}} value) => false;
               static bool INumberBase<{{name}}>.IsInteger({{name}} value) => true;
               static bool INumberBase<{{name}}>.IsNaN({{name}} value) => false;
               static bool INumberBase<{{name}}>.IsNegative({{name}} value) => value.value < 0;
               static bool INumberBase<{{name}}>.IsNegativeInfinity({{name}} value) => false;
               static bool INumberBase<{{name}}>.IsNormal({{name}} value) => value.value != 0;
               static bool INumberBase<{{name}}>.IsOddInteger({{name}} value) => value.value % 2 != 0;
               static bool INumberBase<{{name}}>.IsPositive({{name}} value) => value.value > 0;
               static bool INumberBase<{{name}}>.IsPositiveInfinity({{name}} value) => false;
               static bool INumberBase<{{name}}>.IsRealNumber({{name}} value) => true;
               static bool INumberBase<{{name}}>.IsSubnormal({{name}} value) => false;
               static bool INumberBase<{{name}}>.IsZero({{name}} value) => value.value == 0;
           
               static {{name}} INumberBase<{{name}}>.MaxMagnitude({{name}} x, {{name}} y) =>
                   Math.Abs(x.value) > Math.Abs(y.value) ? x : y;
           
               static {{name}} INumberBase<{{name}}>.MaxMagnitudeNumber({{name}} x, {{name}} y) =>
                   Math.Abs(x.value) > Math.Abs(y.value) ? x : y;
           
               static {{name}} INumberBase<{{name}}>.MinMagnitude({{name}} x, {{name}} y) =>
                   Math.Abs(x.value) < Math.Abs(y.value) ? x : y;
           
               static {{name}} INumberBase<{{name}}>.MinMagnitudeNumber({{name}} x, {{name}} y) =>
                   Math.Abs(x.value) < Math.Abs(y.value) ? x : y;
           
               static int INumberBase<{{name}}>.Radix => 2;
           
               static {{name}} INumberBase<{{name}}>.Abs({{name}} value) =>
                   value.value < 0 ? new(({{backingType}})(-value.value)) : value;
           
               static {{name}} INumberBase<{{name}}>.Parse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider) =>
                   Create({{backingType}}.Parse(s, style, provider));
           
               static {{name}} INumberBase<{{name}}>.Parse(string s, NumberStyles style, IFormatProvider? provider) =>
                   Create({{backingType}}.Parse(s, style, provider));
           
               static bool INumberBase<{{name}}>.TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out {{name}} result)
               {
                   if ({{backingType}}.TryParse(s, style, provider, out var parsed))
                   {
                       result = Create(parsed);
                       return true;
                   }
           
                   result = default;
                   return false;
               }
           
               static bool INumberBase<{{name}}>.TryParse([NotNullWhen(true)] string? s, NumberStyles style, IFormatProvider? provider, out {{name}} result)
               {
                   if ({{backingType}}.TryParse(s, style, provider, out var parsed))
                   {
                       result = Create(parsed);
                       return true;
                   }
           
                   result = default;
                   return false;
               }
         
               #endregion
           
               #region ISpanFormattable/ISpanParsable Implementation
           
               static {{name}} ISpanParsable<{{name}}>.Parse(ReadOnlySpan<char> s, IFormatProvider? provider) =>
                   new({{backingType}}.Parse(s, NumberStyles.Integer, provider));
           
               static bool ISpanParsable<{{name}}>.TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out {{name}} result)
               {
                   if ({{backingType}}.TryParse(s, NumberStyles.Integer, provider, out var value))
                   {
                       result = new(value);
                       return true;
                   }
           
                   result = default;
                   return false;
               }
           
               bool ISpanFormattable.TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider) =>
                   value.TryFormat(destination, out charsWritten, format.ToString(), provider);
           
               static {{name}} IParsable<{{name}}>.Parse(string s, IFormatProvider? provider) =>
                   new({{backingType}}.Parse(s, NumberStyles.Integer, provider));
           
               static bool IParsable<{{name}}>.TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, out {{name}} result)
               {
                   if ({{backingType}}.TryParse(s, NumberStyles.Integer, provider, out var value))
                   {
                       result = new(value);
                       return true;
                   }
           
                   result = default;
                   return false;
               }
           
               #endregion
           
               #region Generic Conversions
           
               static bool INumberBase<{{name}}>.TryConvertFromChecked<TOther>(TOther value, out {{name}} result)
               {
                   if (value is IConvertible conv)
                   {
                       try
                       {
                           var intValue = conv.To{{backingType}}(null);
                           if (intValue >= MinValueConstant && intValue <= MaxValueConstant)
                           {
                               result = Create(intValue);
                               return true;
                           }
                       }
                       catch
                       {
                           // Fall through to default
                       }
                   }
           
                   result = default;
                   return false;
               }
           
               static bool INumberBase<{{name}}>.TryConvertFromSaturating<TOther>(TOther value, out {{name}} result)
               {
                   if (value is IConvertible conv)
                   {
                       try
                       {
                           var intValue = conv.To{{backingType}}(null);
                           result = Create(intValue);
                           return true;
                       }
                       catch
                       {
                           // Fall through to default
                       }
                   }
           
                   result = default;
                   return false;
               }
           
               static bool INumberBase<{{name}}>.TryConvertFromTruncating<TOther>(TOther value, out {{name}} result)
               {
                   if (value is IConvertible conv)
                   {
                       try
                       {
                           var intValue = conv.To{{backingType}}(null);
                           result = Create(intValue);
                           return true;
                       }
                       catch
                       {
                           // Fall through to default
                       }
                   }
           
                   result = default;
                   return false;
               }
           
               static bool INumberBase<{{name}}>.TryConvertToChecked<TOther>({{name}} value, [MaybeNullWhen(false)] out TOther result)
                   where TOther : default
               {
                   if (typeof(TOther) == typeof({{backingType}}))
                   {
                       result = (TOther)(object)value.value;
                       return true;
                   }
           
                   result = default;
                   return false;
               }
           
               static bool INumberBase<{{name}}>.TryConvertToSaturating<TOther>({{name}} value, [MaybeNullWhen(false)] out TOther result)
                   where TOther : default
               {
                   if (typeof(TOther) == typeof({{backingType}}))
                   {
                       result = (TOther)(object)value.value;
                       return true;
                   }
           
                   result = default;
                   return false;
               }
           
               static bool INumberBase<{{name}}>.TryConvertToTruncating<TOther>({{name}} value, [MaybeNullWhen(false)] out TOther result)
                   where TOther : default
               {
                   if (typeof(TOther) == typeof({{backingType}}))
                   {
                       result = (TOther)(object)value.value;
                       return true;
                   }
           
                   result = default;
                   return false;
               }
           
               #endregion
           }
           """;
    }

    private IEnumerable<string> CreateOperators(string name, string backingType)
    {
        if (backingType == "Int64")
        {
            yield return CreateConversionOperatorIn("implicit", "Int64", name);
            yield return CreateConversionOperatorOut("implicit", name, "Int64");
            yield return CreateConversionOperatorIn("implicit", "Int32", name);
            yield return CreateConversionOperatorOut("explicit", name, "Int32");
        }
        else if (backingType == "Int32")
        {
            yield return CreateConversionOperatorIn("implicit", "Int32", name);
            yield return CreateConversionOperatorOut("implicit", name, "Int32");
            yield return CreateConversionOperatorIn("explicit", "Int64", name);
            yield return CreateConversionOperatorOut("implicit", name, "Int64");
        }
        else
        {
            yield return CreateConversionOperatorIn("implicit", backingType, name);
            yield return CreateConversionOperatorOut("implicit", name, backingType);
            yield return CreateConversionOperatorIn("explicit", "Int32", name);
            yield return CreateConversionOperatorOut("implicit", name, "Int32");
            yield return CreateConversionOperatorIn("explicit", "Int64", name);
            yield return CreateConversionOperatorOut("implicit", name, "Int64");
        }
    }

    private string CreateConversionOperatorIn(string type, string fromType, string toType)
    {
        return $"""
        /// <summary>
        /// Defines an {type} conversion of a {fromType} to a <see cref="{toType}"/>.
        /// </summary>
        /// <param name="value">The value to convert.</param>
        /// <returns>A <see cref="{toType}"/> that represents the converted value.</returns>
        public static {type} operator {toType}({fromType} value) => Create(value);
        """;
    }
    
    private string CreateConversionOperatorOut(string type, string fromType, string toType)
    {
        return $"""
        /// <summary>
        /// Defines an {type} conversion of a {fromType} to a <see cref="{toType}"/>.
        /// </summary>
        /// <param name="value">The value to convert.</param>
        /// <returns>A <see cref="{toType}"/> that represents the converted value.</returns>
        public static {type} operator {toType}({fromType} value) => ({toType})value.value;
        """;
    }

// This method generates comparison operators for a specific numeric type
    private string GenerateComparisonOperators(string name, string currentType, string backingType)
    {
        var useDirectCompare = currentType != "ulong" && currentType != "IComparable";
        return $$"""

        // Comparison operators with {{currentType}}
        public static bool operator >({{name}} left, {{currentType}} right) => {{(useDirectCompare ? "left.value > right" : "left.CompareTo(right) > 0")}};
        public static bool operator <({{name}} left, {{currentType}} right) => {{(useDirectCompare ? "left.value < right" : "left.CompareTo(right) < 0")}};
        public static bool operator >=({{name}} left, {{currentType}} right) => {{(useDirectCompare ? "left.value >= right" : "left.CompareTo(right) >= 0")}};
        public static bool operator <=({{name}} left, {{currentType}} right) => {{(useDirectCompare ? "left.value <= right" : "left.CompareTo(right) <= 0")}};

        public static bool operator >({{currentType}} left, {{name}} right) => {{(useDirectCompare ? "left > right.value" : "right.CompareTo(left) < 0")}};
        public static bool operator <({{currentType}} left, {{name}} right) => {{(useDirectCompare ? "left < right.value" : "right.CompareTo(left) > 0")}};
        public static bool operator >=({{currentType}} left, {{name}} right) => {{(useDirectCompare ? "left >= right.value" : "right.CompareTo(left) <= 0")}};
        public static bool operator <=({{currentType}} left, {{name}} right) => {{(useDirectCompare ? "left <= right.value" : "right.CompareTo(left) >= 0")}};
    """;
    }

    private static IEnumerable<string> CreateCreateMethods(string name, string backingType)
    {
        if (backingType == "Int64")
        {
            yield return $"private static {name} Create(Int32 value) => new(value);";
            yield return $"private static {name} Create(Int64 value) => new(value.BalancedModulo(MaxValueConstant));";
            yield return $"private static {name} Create(Int128 value) => new(value.BalancedModulo(MaxValueConstant));";
        }
        else if (backingType == "Int32")
        {
            yield return $"private static {name} Create(Int32 value) => new(value.BalancedModulo(MaxValueConstant));";
            yield return $"private static {name} Create(Int64 value) => new((Int32)value.BalancedModulo((Int64)MaxValueConstant));";
            yield return $"private static {name} Create(Int128 value) => new((Int32)value.BalancedModulo((Int64)MaxValueConstant));";
        }
        else
        {
            yield return $"private static {name} Create({backingType} value) => new(({backingType})((Int32)value).BalancedModulo((Int32)MaxValueConstant));";
            yield return $"private static {name} Create(Int32 value) => new(({backingType})(value.BalancedModulo((Int32)MaxValueConstant)));";
            yield return $"private static {name} Create(Int64 value) => new(({backingType})(value.BalancedModulo((Int64)MaxValueConstant)));";
            yield return $"private static {name} Create(Int128 value) => new(({backingType})value.BalancedModulo((Int64)MaxValueConstant));";
        }
    }

    private string GenerateArithmeticOperators(string name, string backingType)
    {
        var castType = backingType switch
        {
            "Int64" => "(Int128)",
            "Int32" => "(Int64)",
            _ => ""
        };
        
        return $"""

               public static {name} operator +({name} left, {name} right) => Create({castType}left.value + right.value);
               public static {name} operator -({name} left, {name} right) => Create({castType}left.value - right.value);
               public static {name} operator *({name} left, {name} right) => Create({castType}left.value * right.value);
               public static {name} operator /({name} left, {name} right) => Create(left.value / right.value);
               public static {name} operator %({name} left, {name} right) => Create(left.value % right.value);
               public static {name} operator -({name} value) => Create(-value.value);
               public static {name} operator +({name} value) => value;
               public static {name} operator +({name} left, {backingType} right) => Create({castType}left.value + right);
               public static {name} operator +({backingType} left, {name} right) => Create({castType}left + right.value);
               public static {name} operator -({name} left, {backingType} right) => Create({castType}left.value - right);
               public static {name} operator -({backingType} left, {name} right) => Create({castType}left - right.value);
               public static {name} operator *({name} left, {backingType} right) => Create({castType}left.value * right);
               public static {name} operator *({backingType} left, {name} right) => Create({castType}left * right.value);
               public static {name} operator /({name} left, {backingType} right) => Create(left.value / right);
               public static {name} operator /({backingType} left, {name} right) => Create(left / right.value);
               public static {name} operator %({name} left, {backingType} right) => Create(left.value % right);
               public static {name} operator %({backingType} left, {name} right) => Create(left % right.value);
           """;
    }

    private string GenerateBinaryOperations(string name, string backingType)
    {
        var tritArrayName = $"TritArray{name.Substring(3, name.Length - 4)}";
        
        return $$"""

               public static {{name}} operator <<({{name}} value, int shiftAmount) => Create(value.value.Shift(-shiftAmount));
               public static {{name}} operator >> ({{name}} value, int shiftAmount) => Create(value.value.Shift(shiftAmount));
               public static {{name}} operator >>> ({{name}} value, int shiftAmount) => Create(value.value.Shift(shiftAmount));

               /// <summary>
               /// Applies a unary operation to each trit in this ternary number.
               /// </summary>
               /// <param name="value">The ternary number.</param>
               /// <param name="operation">The unary operation to apply to each trit.</param>
               /// <returns>A TritArray containing the result of applying the operation.</returns>
               public static {{tritArrayName}} operator |({{name}} value, Func<Trit, Trit> operation)
               {
                   {{tritArrayName}} array = value;
                   return array | operation;
               }

               /// <summary>
               /// Combines each trit in this ternary number with the corresponding trit in the provided array.
               /// </summary>
               /// <param name="value">The ternary number.</param>
               /// <param name="trits">The array of trits to combine with.</param>
               /// <returns>A TritArray containing the result of the operation.</returns>
               public static {{tritArrayName}} operator |({{name}} value, Trit[] trits)
               {
                   {{tritArrayName}} array = value;
                   return array | trits;
               }
               """;
    }
#>
