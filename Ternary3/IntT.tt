<#@ template debug="false" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>
<#
    // Define the ternary number types to generate
            var ternaryTypes = new List<(string BackingType, int Trits, long BackingTypeMaxValue)>
            {
                ("SByte",3, sbyte.MaxValue),
                // ("SByte", 5, sbyte.MaxValue),
                ("Int16", 9, short.MaxValue),
                // ("Int16", 10, short.MaxValue),
                // ("Int32", 20, int.MaxValue),
                ("Int64", 27, long.MaxValue),
                // ("Int64", 40, long.MaxValue),
            };

            // Loop through each type and generate its file
            foreach (var type in ternaryTypes)
            {
                // Generate the file content
                var fileContent = GenerateTernaryNumberClass(
                    type.BackingType,
                    type.Trits,
                    type.BackingTypeMaxValue
                    );

                // Determine the output file path
                var outputFilePath = Host.ResolvePath($"Int{type.Trits}T.cs");

                // Write the content to the file
                File.WriteAllText(outputFilePath, fileContent);
            }
#>
LastGenerated = <#= DateTime.Now.ToString() #>

<#+
    public static long HalfPow3(long exponent)
    {
        long result = 1;
        while (--exponent > 0)
        {
            result *= 3;
        }
        return 1 + 3 * (result >>  1);
    }

// This method generates the code for a single ternary number struct
    private string GenerateTernaryNumberClass(string backingType, int trits, long backingTypeMaxValue)
    {
        var name = $"Int{trits}T";
        var maxValueConstant = HalfPow3(trits);
        // Check if MaxValueConstant is potentially too big for uint
        var isTooLargeForUint32 = maxValueConstant > uint.MaxValue;
        var useLong = backingType == "Int64";
        var calcType = useLong ? "Int64" : "Int32";

        return $$"""
           // <auto-generated />
           #nullable enable
           namespace Ternary3;
           
           using Integers;
           using Formatting;
           using Operators;
           using Operators.Operations;
           using System.CodeDom.Compiler;
           using System.Diagnostics;
           using System.Globalization;
           using System.Numerics;
           using System.Diagnostics.CodeAnalysis;
           
           /// <summary>
           /// Represents a {{trits}}-trit  signed integer, modeled after the <see cref="{{backingType}}"/> type.
           /// </summary>
           [GeneratedCode("IntT.tt", "1.0.0.0")]
           [DebuggerDisplay("{DebugView()}")]
           public readonly partial struct {{name}} : ITernaryInteger<{{name}}>
           {
               private readonly {{backingType}} value;
           
               /// <summary>
               ///  Represents the maximum value of a <see cref="{{name}}"/>, expressed as a <see cref="{{backingType}}"/> This field is constant.
               /// </summary>
               public const {{backingType}} MaxValueConstant = {{maxValueConstant}};
           
               /// <summary>
               /// Represents the minimum value of a <see cref="{{name}}"/>, expressed as a <see cref="{{backingType}}"/> This field is constant.
               /// </summary>
               public const {{backingType}} MinValueConstant = {{-maxValueConstant}};
           
               /// <summary>
               /// Represents the largest possible value of a <see cref="{{name}}"/>. This field is constant.
               /// </summary>
               public static readonly {{name}} MaxValue = new(MaxValueConstant);
           
               /// <summary>
               /// Represents the smallest possible value of a <see cref="{{name}}"/>. This field is constant.
               /// </summary>
               public static readonly {{name}} MinValue = new(MinValueConstant);
           
               private {{name}}({{backingType}} value) => this.value = value;
               
                {{ string.Join("\r\n     ", CreateCreateMethods(name, backingType)) }}

                {{ string.Join("\r\n     ", CreateOperators(name, backingType)) }}
           
               /// <summary>
               /// Returns a value indicating whether this instance is equal to a specified object.
               /// </summary>
               /// <param name="obj">An object to compare with this instance.</param>
               /// <returns>
               /// <see langword="true"/> if <paramref name="obj"/> is an instance of <see cref="{{name}}"/> or a compatible numeric type
               /// and equals the value of this instance; otherwise, <see langword="false"/>.
               /// </returns>
               public override bool Equals(object? obj)
               {
                   switch (obj)
                   {
                       case null: return false;
                       case {{name}} other: return value == other.value;
                       case int typed: return value == typed;
                       case long int64: return value == int64;
                       case short int16: return value == int16;
                       case byte byteVal: return value == byteVal;
                       case sbyte sbyteVal: return value == sbyteVal;
                       case uint uint32: return value == uint32;
                       case ulong uint64: return value == ({{backingType}})uint64;
                       case ushort uint16: return value == uint16;
                       case float singleValue: return singleValue.Equals(value);
                       case double doubleValue: return doubleValue.Equals(value);
                       case decimal decimalValue: return decimalValue.Equals(value);
                       case char charVal: return value == charVal;
                       case IConvertible conv:
                           try
                           {
                               // ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
                               switch (conv.GetTypeCode())
                               {
                                   case TypeCode.Int16: return value == conv.ToInt16(null);
                                   case TypeCode.UInt16: return value == conv.ToUInt16(null);
                                   case TypeCode.Int32: return value == conv.ToInt32(null);
                                   case TypeCode.UInt32: return value == conv.ToUInt32(null);
                                   case TypeCode.Int64: return value == conv.ToInt64(null);
                                   case TypeCode.UInt64: return value == ({{backingType}})conv.ToUInt64(null);
                                   case TypeCode.Byte: return value == conv.ToByte(null);
                                   case TypeCode.SByte: return value == conv.ToSByte(null);
                                   case TypeCode.Single: return conv.ToSingle(null).Equals(value);
                                   case TypeCode.Double: return conv.ToDouble(null).Equals(value);
                                   case TypeCode.Decimal: return conv.ToDecimal(null).Equals(value);
                               }
                           }
                           catch
                           {
                               return false;
                           }
           
                           break;
                   }
           
                   return obj.Equals(value);
               }
           
               /// <summary>
               /// Returns a value indicating whether this instance is equal to a specified <see cref="{{name}}"/> value.
               /// </summary>
               /// <param name="other">A <see cref="{{name}}"/> value to compare to this instance.</param>
               /// <returns><see langword="true"/> if <paramref name="other"/> has the same value as this instance; otherwise, <see langword="false"/>.</returns>
               public bool Equals({{name}} other) => value == other.value;
           
               /// <summary>
               /// Returns a value indicating whether this instance is equal to a specified <see cref="{{backingType}}"/> value.
               /// </summary>
               /// <param name="other">A <see cref="{{backingType}}"/> value to compare to this instance.</param>
               /// <returns><see langword="true"/> if <paramref name="other"/> has the same value as this instance; otherwise, <see langword="false"/>.</returns>
               public bool Equals({{backingType}} other) => value == other;
           
               /// <summary>
               /// Returns the hash code for this instance.
               /// </summary>
               /// <returns>A 32-bit signed integer hash code.</returns>
               public override int GetHashCode() => value.GetHashCode();
           
               #region Equality Operators
           
               /// <summary>
               /// Returns a value indicating whether two <see cref="{{name}}"/> instances are equal.
               /// </summary>
               /// <param name="left">The first instance to compare.</param>
               /// <param name="right">The second instance to compare.</param>
               /// <returns><see langword="true"/> if the values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <see langword="false"/>.</returns>
               public static bool operator ==(IConvertible left, {{name}} right) => right.Equals(left);
           
               /// <summary>
               /// Returns a value indicating whether two <see cref="{{name}}"/> instances are not equal.
               /// </summary>
               /// <param name="left">The first instance to compare.</param>
               /// <param name="right">The second instance to compare.</param>
               /// <returns><see langword="true"/> if the values of <paramref name="left"/> and <paramref name="right"/> are not equal; otherwise, <see langword="false"/>.</returns>
               public static bool operator !=(IConvertible left, {{name}} right) => !right.Equals(left);
           
               /// <summary>
               /// Returns a value indicating whether two <see cref="{{name}}"/> instances are equal.
               /// </summary>
               /// <param name="left">The first instance to compare.</param>
               /// <param name="right">The second instance to compare.</param>
               /// <returns><see langword="true"/> if the values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <see langword="false"/>.</returns>
               public static bool operator ==({{name}} left, IConvertible right) => left.Equals(right);
           
               /// <summary>
               /// Returns a value indicating whether two <see cref="{{name}}"/> instances are not equal.
               /// </summary>
               /// <param name="left">The first instance to compare.</param>
               /// <param name="right">The second instance to compare.</param>
               /// <returns><see langword="true"/> if the values of <paramref name="left"/> and <paramref name="right"/> are not equal; otherwise, <see langword="false"/>.</returns>
               public static bool operator !=({{name}} left, IConvertible right) => !left.Equals(right);
           
               /// <summary>
               /// Returns a value indicating whether two <see cref="{{name}}"/> instances are equal.
               /// </summary>
               /// <param name="left">The first instance to compare.</param>
               /// <param name="right">The second instance to compare.</param>
               /// <returns><see langword="true"/> if the values of <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <see langword="false"/>.</returns>
               public static bool operator ==({{name}} left, {{name}} right) => left.value == right.value;
           
               /// <summary>
               /// Returns a value indicating whether two <see cref="{{name}}"/> instances are not equal.
               /// </summary>
               /// <param name="left">The first instance to compare.</param>
               /// <param name="right">The second instance to compare.</param>
               /// <returns><see langword="true"/> if the values of <paramref name="left"/> and <paramref name="right"/> are not equal; otherwise, <see langword="false"/>.</returns>
               public static bool operator !=({{name}} left, {{name}} right) => left.value != right.value;
           
               #endregion
           
               #region Arithmetic Operators
               {{GenerateArithmeticOperators(name, backingType)}}
               #endregion
               
               #region Comparison Operators
           
               /// <summary>
               /// Returns a value indicating whether one <see cref="{{name}}"/> is greater than another.
               /// </summary>
               /// <param name="left">The first value to compare.</param>
               /// <param name="right">The second value to compare.</param>
               /// <returns><see langword="true"/> if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise, <see langword="false"/>.</returns>
               public static bool operator >({{name}} left, {{name}} right) => left.value > right.value;
           
               /// <summary>
               /// Returns a value indicating whether one <see cref="{{name}}"/> is less than another.
               /// </summary>
               /// <param name="left">The first value to compare.</param>
               /// <param name="right">The second value to compare.</param>
               /// <returns><see langword="true"/> if <paramref name="left"/> is less than <paramref name="right"/>; otherwise, <see langword="false"/>.</returns>
               public static bool operator <({{name}} left, {{name}} right) => left.value < right.value;
           
               /// <summary>
               /// Returns a value indicating whether one <see cref="{{name}}"/> is greater than or equal to another.
               /// </summary>
               /// <param name="left">The first value to compare.</param>
               /// <param name="right">The second value to compare.</param>
               /// <returns><see langword="true"/> if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise, <see langword="false"/>.</returns>
               public static bool operator >=({{name}} left, {{name}} right) => left.value >= right.value;
           
               /// <summary>
               /// Returns a value indicating whether one <see cref="{{name}}"/> is less than or equal to another.
               /// </summary>
               /// <param name="left">The first value to compare.</param>
               /// <param name="right">The second value to compare.</param>
               /// <returns><see langword="true"/> if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise, <see langword="false"/>.</returns>
               public static bool operator <=({{name}} left, {{name}} right) => left.value <= right.value;
                {{GenerateComparisonOperators(name, "sbyte", backingType)}}
                {{GenerateComparisonOperators(name, "byte", backingType)}}
                {{GenerateComparisonOperators(name, "int", backingType)}}
                {{GenerateComparisonOperators(name, "uint", backingType)}}
                {{GenerateComparisonOperators(name, "short", backingType)}}
                {{GenerateComparisonOperators(name, "ushort", backingType)}}
                {{GenerateComparisonOperators(name, "long", backingType)}}
                {{GenerateComparisonOperators(name, "ulong", backingType)}}
                {{GenerateComparisonOperators(name, "float", backingType)}}
                {{GenerateComparisonOperators(name, "double", backingType)}}
                {{GenerateComparisonOperators(name, "decimal", backingType)}}
                {{GenerateComparisonOperators(name, "IComparable", backingType)}}
           
               #endregion
               
               internal string DebugView() => $"{this} ({this:ter})";
           
               // ToString implementation
               /// <summary>
               /// Returns a string representation of this instance.
               /// </summary>
               public override string ToString() => Formatter.Format(this, null, null);
               /// <summary>
               /// Returns a string representation of this instance.
               /// </summary>
               public string ToString(string? format) =>Formatter.Format(this, format, null);
               /// <summary>
               /// Returns a string representation of this instance.
               /// </summary>
               public string ToString(IFormatProvider? provider) => Formatter.Format(this, null, provider);
               /// <summary>
               /// Returns a string representation of this instance.
               /// </summary>
               public string ToString(string? format, IFormatProvider? provider) =>Formatter.Format(this, format, provider);
               /// <summary>
               /// Returns a string representation of this instance, formatted balanced ternarily according to the specified format.
               /// </summary>
               public string ToString(ITernaryFormat format) => Formatter.Format(this, format);
           
               // Parsing methods
           
               /// <summary>
               /// Parses a string representation of a {{name}}.
               /// </summary>
               /// <param name="value">The string value to parse.</param>
               /// <returns>A {{name}} representing the parsed value.</returns>
               public static {{name}} Parse(string value) => Parser.Parse{{name}}(value);
               
               /// <summary>
               /// Parses a string representation of a {{name}}.
               /// </summary>
               /// <param name="value">The string value to parse.</param>
               /// <param name="format">The format to use for parsing.</param>
               /// <returns>A {{name}} representing the parsed value.</returns>
               public static {{name}} Parse(string value, ITernaryFormat format) => Parser.Parse{{name}}(value, format);
               
               /// <summary>
               /// Parses a string representation of a {{name}}.
               /// </summary>
               /// <param name="value">The string value to parse.</param>
               /// <param name="options">The options to use for parsing.</param>
               /// <returns>A {{name}} representing the parsed value.</returns>
               public static {{name}} Parse(string value, TritParseOptions options) => Parser.Parse{{name}}(value, null, options);
               
               /// <summary>
               /// Parses a string representation of a {{name}}.
               /// </summary>
               /// <param name="value">The string value to parse.</param>
               /// <param name="format">The format to use for parsing.</param>
               /// <param name="options">The options to use for parsing.</param>
               /// <returns>A {{name}} representing the parsed value.</returns>
               public static {{name}} Parse(string value, ITernaryFormat format, TritParseOptions options) => Parser.Parse{{name}}(value, format, options);
           
               /// <summary>
               /// Converts the string representation of a number in a specified style to its <see cref="{{name}}"/> equivalent.
               /// </summary>
               /// <param name="s">A string containing a number to convert.</param>
               /// <param name="style">A bitwise combination of enumeration values that indicate the style elements that can be present in <paramref name="s"/>.</param>
               /// <returns>A <see cref="{{name}}"/> equivalent to the number contained in <paramref name="s"/>.</returns>
               /// <exception cref="ArgumentNullException"><paramref name="s"/> is <see langword="null"/>.</exception>
               /// <exception cref="ArgumentException"><paramref name="style"/> is not a <see cref="NumberStyles"/> value or <paramref name="style"/> includes the <see cref="NumberStyles.AllowHexSpecifier"/> value.</exception>
               /// <exception cref="FormatException"><paramref name="s"/> is not in a format compliant with <paramref name="style"/>.</exception>
               /// <exception cref="OverflowException"><paramref name="s"/> represents a number less than <see cref="{{name}}.MinValue"/> or greater than <see cref="{{name}}.MaxValue"/>.</exception>
               public static {{name}} Parse(string s, NumberStyles style) => Create({{backingType}}.Parse(s, style));
           
               /// <summary>
               /// Tries to convert the string representation of a number to its <see cref="{{name}}"/> equivalent, and returns a value that indicates whether the conversion succeeded.
               /// </summary>
               /// <param name="s">A string containing a number to convert.</param>
               /// <param name="result">When this method returns, contains the <see cref="{{name}}"/> value equivalent to the number contained in <paramref name="s"/> if the conversion succeeded, or zero if the conversion failed. This parameter is passed uninitialized.</param>
               /// <returns><see langword="true"/> if <paramref name="s"/> was converted successfully; otherwise, <see langword="false"/>.</returns>
               public static bool TryParse(string? s, out {{name}} result)
               {
                   bool success = {{backingType}}.TryParse(s, out {{backingType}} value);
                   result = new {{name}}(value);
                   return success;
               }
           
               /// <summary>
               /// Compares this instance to a specified object and returns an indication of their relative values.
               /// </summary>
               /// <param name="obj">An object to compare, or <see langword="null"/>.</param>
               /// <returns>
               /// A signed number indicating the relative values of this instance and <paramref name="obj"/>.
               /// Return Value Description:
               /// Less than zero: This instance is less than <paramref name="obj"/>.
               /// Zero: This instance is equal to <paramref name="obj"/>.
               /// Greater than zero: This instance is greater than <paramref name="obj"/> or <paramref name="obj"/> is <see langword="null"/>.
               /// </returns>
               /// <exception cref="ArgumentException"><paramref name="obj"/> is not a <see cref="{{name}}"/> or a type that can be converted to an integer.</exception>
               public int CompareTo(object? obj)
               {
                   if (obj == null) return 1;
                   if (obj is {{name}} other) return CompareTo(other);
           
                   // For large numeric types that exceed {{name}}'s range, return -1 if greater than MaxValue, 1 if less than MinValue
                   try
                   {
                       if (obj is {{backingType}} typed) return value.CompareTo(typed);
                       if (obj is long int64)
                       {
                           return int64 switch
                           {
                               > MaxValueConstant => -1,
                               < MinValueConstant => 1,
                               _ => value.CompareTo(({{backingType}})int64)
                           };
                       }
           
                       if (obj is uint uint32)
                       {
                           return {{(isTooLargeForUint32
                               ? $"value.CompareTo(({backingType})uint32);"
                               : $"uint32 > MaxValueConstant ? -1 : value.CompareTo(({backingType})uint32);")}}
                       }
           
                       if (obj is ulong uint64)
                       {
                           return uint64 > (long)MaxValueConstant ? -1 : value.CompareTo(({{backingType}})uint64);
                       }
           
                       if (obj is short int16) return value.CompareTo(int16);
                       if (obj is ushort uint16) return value.CompareTo(uint16);
                       if (obj is byte byteVal) return value.CompareTo(byteVal);
                       if (obj is sbyte sbyteVal) return value.CompareTo(sbyteVal);
                       if (obj is float singleValue)
                       {
                           return singleValue switch
                           {
                               > MaxValueConstant => -1,
                               < MinValueConstant => 1,
                               _ => value.CompareTo(({{backingType}})singleValue)
                           };
                       }
           
                       if (obj is double doubleValue)
                       {
                           return doubleValue switch
                           {
                               > MaxValueConstant => -1,
                               < MinValueConstant => 1,
                               _ => value.CompareTo(({{backingType}})doubleValue)
                           };
                       }
           
                       if (obj is decimal decimalValue)
                       {
                           return decimalValue switch
                           {
                               > MaxValueConstant => -1,
                               < MinValueConstant => 1,
                               _ => value.CompareTo(({{backingType}})decimalValue)
                           };
                       }
           
                       if (obj is IConvertible convertible)
                       {
                           switch (convertible.GetTypeCode())
                           {
                               case TypeCode.Int16:
                               case TypeCode.UInt16:
                               case TypeCode.Byte:
                               case TypeCode.SByte:
                                   return value.CompareTo(convertible.ToInt32(null));
                               case TypeCode.Int32:
                                   return value.CompareTo(convertible.ToInt32(null));
                               case TypeCode.UInt32:
                                   var uint32Value = convertible.ToUInt32(null);
                                   {{(isTooLargeForUint32 ? "" : "if (uint32Value > MaxValueConstant) return -1;")}}
                                   return value.CompareTo(({{backingType}})uint32Value);
                               case TypeCode.Int64:
                                   var int64Value = convertible.ToInt64(null);
                                   if (int64Value > MaxValueConstant) return -1;
                                   if (int64Value < MinValueConstant) return 1;
                                   return value.CompareTo(({{backingType}})(int64Value));
                               case TypeCode.UInt64:
                                   var uint64Value = convertible.ToUInt64(null);
                                   if (uint64Value > (long)MaxValueConstant) return -1;
                                   return value.CompareTo(({{backingType}})uint64Value);
                               case TypeCode.Single:
                                   var singleVal = convertible.ToSingle(null);
                                   if (singleVal > MaxValueConstant) return -1;
                                   if (singleVal < MinValueConstant) return 1;
                                   return value.CompareTo(({{backingType}})singleVal);
                               case TypeCode.Double:
                                   var doubleVal = convertible.ToDouble(null);
                                   if (doubleVal > MaxValueConstant) return -1;
                                   if (doubleVal < MinValueConstant) return 1;
                                   return value.CompareTo(({{backingType}})doubleVal);
                               case TypeCode.Decimal:
                                   var decimalVal = convertible.ToDecimal(null);
                                   if (decimalVal > MaxValueConstant) return -1;
                                   if (decimalVal < MinValueConstant) return 1;
                                   return value.CompareTo(({{backingType}})decimalVal);
                           }
                       }
                   }
                   catch (OverflowException)
                   {
                       // If conversion fails due to overflow, we can assume the value is outside our range
                       return -1;
                   }
           
                   throw new ArgumentException("Object is not a valid type for comparison", nameof(obj));
               }
           
               /// <summary>
               /// Compares this instance to a specified <see cref="{{name}}"/> object and returns an indication of their relative values.
               /// </summary>
               /// <param name="other">An <see cref="{{name}}"/> object to compare.</param>
               /// <returns>
               /// A signed number indicating the relative values of this instance and <paramref name="other"/>.
               /// Return Value Description:
               /// Less than zero: This instance is less than <paramref name="other"/>.
               /// Zero: This instance is equal to <paramref name="other"/>.
               /// Greater than zero: This instance is greater than <paramref name="other"/>.
               /// </returns>
               public int CompareTo({{name}} other) => value.CompareTo(other.value);
           
               #region IConvertible Implementation
           
               /// <summary>
               /// Gets the <see cref="TypeCode"/> for this instance.
               /// </summary>
               /// <returns><see cref="TypeCode.Int32"/>.</returns>
               public TypeCode GetTypeCode() => TypeCode.Int32;

               /// <summary>
               /// Converts this instance to a <see cref="bool"/> value.
               /// </summary>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns><see langword="true"/> if the value is non-zero; otherwise, <see langword="false"/>.</returns>
               bool IConvertible.ToBoolean(IFormatProvider? provider) => value != 0;

               /// <summary>
               /// Converts this instance to a <see cref="char"/> value.
               /// </summary>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns>A <see cref="char"/> value equivalent to this instance.</returns>
               char IConvertible.ToChar(IFormatProvider? provider) => Convert.ToChar(value);

               /// <summary>
               /// Converts this instance to an <see cref="sbyte"/> value.
               /// </summary>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns>An <see cref="sbyte"/> value equivalent to this instance.</returns>
               sbyte IConvertible.ToSByte(IFormatProvider? provider) => Convert.ToSByte(value);

               /// <summary>
               /// Converts this instance to a <see cref="byte"/> value.
               /// </summary>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns>A <see cref="byte"/> value equivalent to this instance.</returns>
               byte IConvertible.ToByte(IFormatProvider? provider) => Convert.ToByte(value);

               /// <summary>
               /// Converts this instance to a <see cref="short"/> value.
               /// </summary>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns>A <see cref="short"/> value equivalent to this instance.</returns>
               short IConvertible.ToInt16(IFormatProvider? provider) => Convert.ToInt16(value);

               /// <summary>
               /// Converts this instance to a <see cref="ushort"/> value.
               /// </summary>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns>A <see cref="ushort"/> value equivalent to this instance.</returns>
               ushort IConvertible.ToUInt16(IFormatProvider? provider) => Convert.ToUInt16(value);

               /// <summary>
               /// Converts this instance to an <see cref="int"/> value.
               /// </summary>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns>An <see cref="int"/> value equivalent to this instance.</returns>
               int IConvertible.ToInt32(IFormatProvider? provider) => Convert.ToInt32(value);

               /// <summary>
               /// Converts this instance to a <see cref="uint"/> value.
               /// </summary>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns>A <see cref="uint"/> value equivalent to this instance.</returns>
               uint IConvertible.ToUInt32(IFormatProvider? provider) => Convert.ToUInt32(value);

               /// <summary>
               /// Converts this instance to a <see cref="long"/> value.
               /// </summary>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns>A <see cref="long"/> value equivalent to this instance.</returns>
               long IConvertible.ToInt64(IFormatProvider? provider) => Convert.ToInt64(value);

               /// <summary>
               /// Converts this instance to a <see cref="ulong"/> value.
               /// </summary>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns>A <see cref="ulong"/> value equivalent to this instance.</returns>
               ulong IConvertible.ToUInt64(IFormatProvider? provider) => Convert.ToUInt64(value);

               /// <summary>
               /// Converts this instance to a <see cref="float"/> value.
               /// </summary>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns>A <see cref="float"/> value equivalent to this instance.</returns>
               float IConvertible.ToSingle(IFormatProvider? provider) => Convert.ToSingle(value);

               /// <summary>
               /// Converts this instance to a <see cref="double"/> value.
               /// </summary>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns>A <see cref="double"/> value equivalent to this instance.</returns>
               double IConvertible.ToDouble(IFormatProvider? provider) => Convert.ToDouble(value);

               /// <summary>
               /// Converts this instance to a <see cref="decimal"/> value.
               /// </summary>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns>A <see cref="decimal"/> value equivalent to this instance.</returns>
               decimal IConvertible.ToDecimal(IFormatProvider? provider) => Convert.ToDecimal(value);

               /// <summary>
               /// This conversion is not supported and will always throw <see cref="InvalidCastException"/>.
               /// </summary>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns>This method never returns; it always throws <see cref="InvalidCastException"/>.</returns>
               /// <exception cref="InvalidCastException">This conversion is not supported.</exception>
               DateTime IConvertible.ToDateTime(IFormatProvider? provider) => throw new InvalidCastException();

               /// <summary>
               /// Converts this instance to its string representation.
               /// </summary>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns>A string representation of this instance.</returns>
               string IConvertible.ToString(IFormatProvider? provider) => value.ToString(provider);

               /// <summary>
               /// Converts this instance to an object of the specified type.
               /// </summary>
               /// <param name="conversionType">The target type for the conversion.</param>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns>An object whose type is <paramref name="conversionType"/> and whose value is equivalent to this instance.</returns>
               object IConvertible.ToType(Type conversionType, IFormatProvider? provider) =>
                   Convert.ChangeType(value, conversionType, provider);

               #endregion
           
               #region IUtf8SpanFormattable Implementation
           
               bool IUtf8SpanFormattable.TryFormat(Span<byte> utf8Destination, out int bytesWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
                    => Formatter.TryFormat(value, utf8Destination, out bytesWritten, format, provider);
           
               #endregion
           
               #region IIncrementOperators/IDecrementOperators Implementation
           
               /// <summary>
               /// Increments a ternary number by one, maintaining the original numeric type.
               /// </summary>
               /// <param name="value">The ternary number to increment.</param>
               /// <returns>A new ternary number with a value one greater than <paramref name="value"/>.</returns>
               public static {{name}} operator ++({{name}} value) => Create(value.value + 1);

               /// <summary>
               /// Decrements a ternary number by one, maintaining the original numeric type.
               /// </summary>
               /// <param name="value">The ternary number to decrement.</param>
               /// <returns>A new ternary number with a value one less than <paramref name="value"/>.</returns>
               public static {{name}} operator --({{name}} value) => Create(value.value - 1);

               #endregion

               /// <summary>
               /// Determines whether two <see cref="{{name}}"/> values are equal.
               /// </summary>
               /// <param name="left">The first value to compare.</param>
               /// <param name="right">The second value to compare.</param>
               /// <returns><see langword="true"/> if <paramref name="left"/> is equal to <paramref name="right"/>; otherwise, <see langword="false"/>.</returns>
               static bool IEqualityOperators<{{name}}, {{name}}, bool>.operator ==({{name}} left, {{name}} right) => left.value == right.value;

               /// <summary>
               /// Determines whether two <see cref="{{name}}"/> values are not equal.
               /// </summary>
               /// <param name="left">The first value to compare.</param>
               /// <param name="right">The second value to compare.</param>
               /// <returns><see langword="true"/> if <paramref name="left"/> is not equal to <paramref name="right"/>; otherwise, <see langword="false"/>.</returns>
               static bool IEqualityOperators<{{name}}, {{name}}, bool>.operator !=({{name}} left, {{name}} right) => left.value != right.value;
           
               #region Binary Operations

               {{GenerateBinaryOperations(name, backingType)}}

               #endregion
               
               #region Indexers
               
               /// <summary>
               /// Gets the trit at the specified index in this <see cref="{{name}}"/>.
               /// </summary>
               public Trit this[int index] => TritShift.Index(value, index, {{trits}});
               
               /// <summary>
               /// Gets the trit at the specified index in this <see cref="{{name}}"/>.
               /// </summary>
               public Trit this[Index index] => TritShift.Index(value, index.GetOffset({{trits}}), {{trits}});
               
               #endregion
           
               #region Interface Static Members
           
               /// <summary>
               /// Returns the value -1 as a <see cref="{{name}}"/>.
               /// </summary>
               static {{name}} ISignedNumber<{{name}}>.NegativeOne => new(-1);

               /// <summary>
               /// Returns the value 1 as a <see cref="{{name}}"/>.
               /// </summary>
               static {{name}} INumberBase<{{name}}>.One => new(1);

               /// <summary>
               /// Returns the value 0 as a <see cref="{{name}}"/>.
               /// </summary>
               static {{name}} INumberBase<{{name}}>.Zero => new(0);

               /// <summary>
               /// Returns the additive identity (0) for <see cref="{{name}}"/>.
               /// </summary>
               static {{name}} IAdditiveIdentity<{{name}}, {{name}}>.AdditiveIdentity => new(0);

               /// <summary>
               /// Returns the multiplicative identity (1) for <see cref="{{name}}"/>.
               /// </summary>
               static {{name}} IMultiplicativeIdentity<{{name}}, {{name}}>.MultiplicativeIdentity => new(1);

               /// <summary>
               /// Returns <see langword="true"/> as all <see cref="{{name}}"/> values are canonical.
               /// </summary>
               static bool INumberBase<{{name}}>.IsCanonical({{name}} value) => true;

               /// <summary>
               /// Returns <see langword="false"/> as <see cref="{{name}}"/> values are not complex numbers.
               /// </summary>
               static bool INumberBase<{{name}}>.IsComplexNumber({{name}} value) => false;

               /// <summary>
               /// Determines whether the specified value is an even integer.
               /// </summary>
               static bool INumberBase<{{name}}>.IsEvenInteger({{name}} value) => value.value % 2 == 0;

               /// <summary>
               /// Returns <see langword="true"/> as all <see cref="{{name}}"/> values are finite.
               /// </summary>
               static bool INumberBase<{{name}}>.IsFinite({{name}} value) => true;

               /// <summary>
               /// Returns <see langword="false"/> as <see cref="{{name}}"/> values are not imaginary numbers.
               /// </summary>
               static bool INumberBase<{{name}}>.IsImaginaryNumber({{name}} value) => false;

               /// <summary>
               /// Returns <see langword="false"/> as <see cref="{{name}}"/> values cannot be infinite.
               /// </summary>
               static bool INumberBase<{{name}}>.IsInfinity({{name}} value) => false;

               /// <summary>
               /// Returns <see langword="true"/> as all <see cref="{{name}}"/> values are integers.
               /// </summary>
               static bool INumberBase<{{name}}>.IsInteger({{name}} value) => true;

               /// <summary>
               /// Returns <see langword="false"/> as <see cref="{{name}}"/> values cannot be NaN.
               /// </summary>
               static bool INumberBase<{{name}}>.IsNaN({{name}} value) => false;

               /// <summary>
               /// Returns <see langword="true"/> if the value is less than zero.
               /// </summary>
               static bool INumberBase<{{name}}>.IsNegative({{name}} value) => value.value < 0;

               /// <summary>
               /// Returns <see langword="false"/> as <see cref="{{name}}"/> values cannot be negative infinity.
               /// </summary>
               static bool INumberBase<{{name}}>.IsNegativeInfinity({{name}} value) => false;

               /// <summary>
               /// Returns <see langword="true"/> if the value is non-zero.
               /// </summary>
               static bool INumberBase<{{name}}>.IsNormal({{name}} value) => value.value != 0;

               /// <summary>
               /// Determines whether the specified value is an odd integer.
               /// </summary>
               static bool INumberBase<{{name}}>.IsOddInteger({{name}} value) => value.value % 2 != 0;

               /// <summary>
               /// Returns <see langword="true"/> if the value is greater than zero.
               /// </summary>
               static bool INumberBase<{{name}}>.IsPositive({{name}} value) => value.value > 0;

               /// <summary>
               /// Returns <see langword="false"/> as <see cref="{{name}}"/> values cannot be positive infinity.
               /// </summary>
               static bool INumberBase<{{name}}>.IsPositiveInfinity({{name}} value) => false;

               /// <summary>
               /// Returns <see langword="true"/> as all <see cref="{{name}}"/> values are real numbers.
               /// </summary>
               static bool INumberBase<{{name}}>.IsRealNumber({{name}} value) => true;

               /// <summary>
               /// Returns <see langword="false"/> as <see cref="{{name}}"/> values cannot be subnormal.
               /// </summary>
               static bool INumberBase<{{name}}>.IsSubnormal({{name}} value) => false;

               /// <summary>
               /// Returns <see langword="true"/> if the value is zero.
               /// </summary>
               static bool INumberBase<{{name}}>.IsZero({{name}} value) => value.value == 0;

               /// <summary>
               /// Returns the value with the greater absolute value.
               /// </summary>
               static {{name}} INumberBase<{{name}}>.MaxMagnitude({{name}} x, {{name}} y) =>
                   Math.Abs(x.value) > Math.Abs(y.value) ? x : y;

               /// <summary>
               /// Returns the value with the greater absolute value.
               /// </summary>
               static {{name}} INumberBase<{{name}}>.MaxMagnitudeNumber({{name}} x, {{name}} y) =>
                   Math.Abs(x.value) > Math.Abs(y.value) ? x : y;

               /// <summary>
               /// Returns the value with the lesser absolute value.
               /// </summary>
               static {{name}} INumberBase<{{name}}>.MinMagnitude({{name}} x, {{name}} y) =>
                   Math.Abs(x.value) < Math.Abs(y.value) ? x : y;

               /// <summary>
               /// Returns the value with the lesser absolute value.
               /// </summary>
               static {{name}} INumberBase<{{name}}>.MinMagnitudeNumber({{name}} x, {{name}} y) =>
                   Math.Abs(x.value) < Math.Abs(y.value) ? x : y;

               /// <summary>
               /// Gets the radix (base) for this numeric type.
               /// </summary>
               static int INumberBase<{{name}}>.Radix => 2;

               /// <summary>
               /// Returns the absolute value of the specified value.
               /// </summary>
               static {{name}} INumberBase<{{name}}>.Abs({{name}} value) =>
                   value.value < 0 ? new(({{backingType}})(-value.value)) : value;
           
               static {{name}} INumberBase<{{name}}>.Parse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider) =>
                   Create({{backingType}}.Parse(s, style, provider));
           
               static {{name}} INumberBase<{{name}}>.Parse(string s, NumberStyles style, IFormatProvider? provider) =>
                   Create({{backingType}}.Parse(s, style, provider));
           
               static bool INumberBase<{{name}}>.TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out {{name}} result)
               {
                   if ({{backingType}}.TryParse(s, style, provider, out var parsed))
                   {
                       result = Create(parsed);
                       return true;
                   }
           
                   result = default;
                   return false;
               }
           
               static bool INumberBase<{{name}}>.TryParse([NotNullWhen(true)] string? s, NumberStyles style, IFormatProvider? provider, out {{name}} result)
               {
                   if ({{backingType}}.TryParse(s, style, provider, out var parsed))
                   {
                       result = Create(parsed);
                       return true;
                   }
           
                   result = default;
                   return false;
               }
         
               #endregion
           
               #region ISpanFormattable/ISpanParsable Implementation
           
               /// <summary>
               /// Parses a ternary number from a character span.
               /// </summary>
               /// <param name="s">The span containing the characters to parse.</param>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns>A <see cref="{{name}}"/> that represents the parsed value.</returns>
               static {{name}} ISpanParsable<{{name}}>.Parse(ReadOnlySpan<char> s, IFormatProvider? provider) =>
                   new({{backingType}}.Parse(s, NumberStyles.Integer, provider));

               /// <summary>
               /// Attempts to parse a ternary number from a character span.
               /// </summary>
               /// <param name="s">The span containing the characters to parse.</param>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <param name="result">When this method returns, contains the parsed value if successful; otherwise, the default value.</param>
               /// <returns><see langword="true"/> if the parsing was successful; otherwise, <see langword="false"/>.</returns>
               static bool ISpanParsable<{{name}}>.TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out {{name}} result)
               {
                   if ({{backingType}}.TryParse(s, NumberStyles.Integer, provider, out var value))
                   {
                       result = new(value);
                       return true;
                   }

                   result = default;
                   return false;
               }

               /// <summary>
               /// Tries to format the value of the current instance into the provided span of characters.
               /// </summary>
               /// <param name="destination">The span in which to write this instance's value formatted as a span of characters.</param>
               /// <param name="charsWritten">When this method returns, contains the number of characters that were written in <paramref name="destination"/>.</param>
               /// <param name="format">A span containing the characters that represent a standard or custom format string.</param>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns><see langword="true"/> if the formatting was successful; otherwise, <see langword="false"/>.</returns>
               bool ISpanFormattable.TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider) 
                   => Formatter.TryFormat(value, destination, out charsWritten, format, provider);

               /// <summary>
               /// Parses a string to a ternary number.
               /// </summary>
               /// <param name="s">The string to parse.</param>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <returns>A <see cref="{{name}}"/> that represents the parsed value.</returns>
               static {{name}} IParsable<{{name}}>.Parse(string s, IFormatProvider? provider) =>
                   new({{backingType}}.Parse(s, NumberStyles.Integer, provider));

               /// <summary>
               /// Attempts to parse a string to a ternary number.
               /// </summary>
               /// <param name="s">The string to parse.</param>
               /// <param name="provider">An object that supplies culture-specific formatting information.</param>
               /// <param name="result">When this method returns, contains the parsed value if successful; otherwise, the default value.</param>
               /// <returns><see langword="true"/> if the parsing was successful; otherwise, <see langword="false"/>.</returns>
               static bool IParsable<{{name}}>.TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, out {{name}} result)
               {
                   if ({{backingType}}.TryParse(s, NumberStyles.Integer, provider, out var value))
                   {
                       result = new(value);
                       return true;
                   }

                   result = default;
                   return false;
               }

               #endregion
           
               #region Generic Conversions
           
               /// <summary>
               /// Attempts to convert a value to a ternary number with overflow checking.
               /// </summary>
               /// <typeparam name="TOther">The type to convert from.</typeparam>
               /// <param name="value">The value to convert.</param>
               /// <param name="result">When this method returns, contains the converted value if successful; otherwise, the default value.</param>
               /// <returns><see langword="true"/> if the conversion was successful; otherwise, <see langword="false"/>.</returns>
               static bool INumberBase<{{name}}>.TryConvertFromChecked<TOther>(TOther value, out {{name}} result)
               {
                   if (value is IConvertible conv)
                   {
                       try
                       {
                           var intValue = conv.To{{backingType}}(null);
                           if (intValue >= MinValueConstant && intValue <= MaxValueConstant)
                           {
                               result = Create(intValue);
                               return true;
                           }
                       }
                       catch
                       {
                           // Fall through to default
                       }
                   }

                   result = default;
                   return false;
               }

               /// <summary>
               /// Attempts to convert a value to a ternary number with saturation.
               /// </summary>
               /// <typeparam name="TOther">The type to convert from.</typeparam>
               /// <param name="value">The value to convert.</param>
               /// <param name="result">When this method returns, contains the converted value if successful; otherwise, the default value.</param>
               /// <returns><see langword="true"/> if the conversion was successful; otherwise, <see langword="false"/>.</returns>
               static bool INumberBase<{{name}}>.TryConvertFromSaturating<TOther>(TOther value, out {{name}} result)
               {
                   if (value is IConvertible conv)
                   {
                       try
                       {
                           var intValue = conv.To{{backingType}}(null);
                           result = Create(intValue);
                           return true;
                       }
                       catch
                       {
                           // Fall through to default
                       }
                   }

                   result = default;
                   return false;
               }

               /// <summary>
               /// Attempts to convert a value to a ternary number with truncation.
               /// </summary>
               /// <typeparam name="TOther">The type to convert from.</typeparam>
               /// <param name="value">The value to convert.</param>
               /// <param name="result">When this method returns, contains the converted value if successful; otherwise, the default value.</param>
               /// <returns><see langword="true"/> if the conversion was successful; otherwise, <see langword="false"/>.</returns>
               static bool INumberBase<{{name}}>.TryConvertFromTruncating<TOther>(TOther value, out {{name}} result)
               {
                   if (value is IConvertible conv)
                   {
                       try
                       {
                           var intValue = conv.To{{backingType}}(null);
                           result = Create(intValue);
                           return true;
                       }
                       catch
                       {
                           // Fall through to default
                       }
                   }

                   result = default;
                   return false;
               }

               /// <summary>
               /// Attempts to convert a ternary number to another type with overflow checking.
               /// </summary>
               /// <typeparam name="TOther">The type to convert to.</typeparam>
               /// <param name="value">The value to convert.</param>
               /// <param name="result">When this method returns, contains the converted value if successful; otherwise, the default value.</param>
               /// <returns><see langword="true"/> if the conversion was successful; otherwise, <see langword="false"/>.</returns>
               static bool INumberBase<{{name}}>.TryConvertToChecked<TOther>({{name}} value, [MaybeNullWhen(false)] out TOther result)
                   where TOther : default
               {
                   if (typeof(TOther) == typeof({{backingType}}))
                   {
                       result = (TOther)(object)value.value;
                       return true;
                   }

                   result = default;
                   return false;
               }

               /// <summary>
               /// Attempts to convert a ternary number to another type with saturation.
               /// </summary>
               /// <typeparam name="TOther">The type to convert to.</typeparam>
               /// <param name="value">The value to convert.</param>
               /// <param name="result">When this method returns, contains the converted value if successful; otherwise, the default value.</param>
               /// <returns><see langword="true"/> if the conversion was successful; otherwise, <see langword="false"/>.</returns>
               static bool INumberBase<{{name}}>.TryConvertToSaturating<TOther>({{name}} value, [MaybeNullWhen(false)] out TOther result)
                   where TOther : default
               {
                   if (typeof(TOther) == typeof({{backingType}}))
                   {
                       result = (TOther)(object)value.value;
                       return true;
                   }

                   result = default;
                   return false;
               }

               /// <summary>
               /// Attempts to convert a ternary number to another type with truncation.
               /// </summary>
               /// <typeparam name="TOther">The type to convert to.</typeparam>
               /// <param name="value">The value to convert.</param>
               /// <param name="result">When this method returns, contains the converted value if successful; otherwise, the default value.</param>
               /// <returns><see langword="true"/> if the conversion was successful; otherwise, <see langword="false"/>.</returns>
               static bool INumberBase<{{name}}>.TryConvertToTruncating<TOther>({{name}} value, [MaybeNullWhen(false)] out TOther result)
                   where TOther : default
               {
                   if (typeof(TOther) == typeof({{backingType}}))
                   {
                       result = (TOther)(object)value.value;
                       return true;
                   }

                   result = default;
                   return false;
               }

               #endregion
           }
           """;
    }

    private IEnumerable<string> CreateOperators(string name, string backingType)
    {
        if (backingType == "Int64")
        {
            yield return CreateConversionOperatorIn("implicit", "Int64", name);
            yield return CreateConversionOperatorOut("implicit", name, "Int64");
            yield return CreateConversionOperatorIn("implicit", "Int32", name);
            yield return CreateConversionOperatorOut("explicit", name, "Int32");
        }
        else if (backingType == "Int32")
        {
            yield return CreateConversionOperatorIn("implicit", "Int32", name);
            yield return CreateConversionOperatorOut("implicit", name, "Int32");
            yield return CreateConversionOperatorIn("explicit", "Int64", name);
            yield return CreateConversionOperatorOut("implicit", name, "Int64");
        }
        else
        {
            yield return CreateConversionOperatorIn("implicit", backingType, name);
            yield return CreateConversionOperatorOut("implicit", name, backingType);
            yield return CreateConversionOperatorIn("explicit", "Int32", name);
            yield return CreateConversionOperatorOut("implicit", name, "Int32");
            yield return CreateConversionOperatorIn("explicit", "Int64", name);
            yield return CreateConversionOperatorOut("implicit", name, "Int64");
        }
        yield return CreateConversionOperatorIn("explicit", "Int128", name);
        yield return CreateConversionOperatorOut("implicit", name, "Int128");
    }

    private string CreateConversionOperatorIn(string type, string fromType, string toType)
    {
        return $"""
        /// <summary>
        /// Defines an {type} conversion of a {fromType} to a <see cref="{toType}"/>.
        /// </summary>
        /// <param name="value">The value to convert.</param>
        /// <returns>A <see cref="{toType}"/> that represents the converted value.</returns>
        public static {type} operator {toType}({fromType} value) => Create(value);
        """;
    }
    
    private string CreateConversionOperatorOut(string type, string fromType, string toType)
    {
        return $"""
        /// <summary>
        /// Defines an {type} conversion of a {fromType} to a <see cref="{toType}"/>.
        /// </summary>
        /// <param name="value">The value to convert.</param>
        /// <returns>A <see cref="{toType}"/> that represents the converted value.</returns>
        public static {type} operator {toType}({fromType} value) => ({toType})value.value;
        """;
    }

// This method generates comparison operators for a specific numeric type
    private string GenerateComparisonOperators(string name, string currentType, string backingType)
    {
        var useDirectCompare = currentType != "ulong" && currentType != "IComparable";
        return $$"""

        // Comparison operators with {{currentType}}
        /// <summary>
        /// Returns a value indicating whether a <see cref="{{name}}"/> value is greater than a <see cref="{{currentType}}"/> value.
        /// </summary>
        /// <param name="left">The <see cref="{{name}}"/> value to compare.</param>
        /// <param name="right">The <see cref="{{currentType}}"/> value to compare.</param>
        /// <returns><see langword="true"/> if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise, <see langword="false"/>.</returns>
        public static bool operator >({{name}} left, {{currentType}} right) => {{(useDirectCompare ? "left.value > right" : "left.CompareTo(right) > 0")}};

        /// <summary>
        /// Returns a value indicating whether a <see cref="{{name}}"/> value is less than a <see cref="{{currentType}}"/> value.
        /// </summary>
        /// <param name="left">The <see cref="{{name}}"/> value to compare.</param>
        /// <param name="right">The <see cref="{{currentType}}"/> value to compare.</param>
        /// <returns><see langword="true"/> if <paramref name="left"/> is less than <paramref name="right"/>; otherwise, <see langword="false"/>.</returns>
        public static bool operator <({{name}} left, {{currentType}} right) => {{(useDirectCompare ? "left.value < right" : "left.CompareTo(right) < 0")}};

        /// <summary>
        /// Returns a value indicating whether a <see cref="{{name}}"/> value is greater than or equal to a <see cref="{{currentType}}"/> value.
        /// </summary>
        /// <param name="left">The <see cref="{{name}}"/> value to compare.</param>
        /// <param name="right">The <see cref="{{currentType}}"/> value to compare.</param>
        /// <returns><see langword="true"/> if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise, <see langword="false"/>.</returns>
        public static bool operator >=({{name}} left, {{currentType}} right) => {{(useDirectCompare ? "left.value >= right" : "left.CompareTo(right) >= 0")}};

        /// <summary>
        /// Returns a value indicating whether a <see cref="{{name}}"/> value is less than or equal to a <see cref="{{currentType}}"/> value.
        /// </summary>
        /// <param name="left">The <see cref="{{name}}"/> value to compare.</param>
        /// <param name="right">The <see cref="{{currentType}}"/> value to compare.</param>
        /// <returns><see langword="true"/> if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise, <see langword="false"/>.</returns>
        public static bool operator <=({{name}} left, {{currentType}} right) => {{(useDirectCompare ? "left.value <= right" : "left.CompareTo(right) <= 0")}};

        /// <summary>
        /// Returns a value indicating whether a <see cref="{{currentType}}"/> value is greater than a <see cref="{{name}}"/> value.
        /// </summary>
        /// <param name="left">The <see cref="{{currentType}}"/> value to compare.</param>
        /// <param name="right">The <see cref="{{name}}"/> value to compare.</param>
        /// <returns><see langword="true"/> if <paramref name="left"/> is greater than <paramref name="right"/>; otherwise, <see langword="false"/>.</returns>
        public static bool operator >({{currentType}} left, {{name}} right) => {{(useDirectCompare ? "left > right.value" : "right.CompareTo(left) < 0")}};

        /// <summary>
        /// Returns a value indicating whether a <see cref="{{currentType}}"/> value is less than a <see cref="{{name}}"/> value.
        /// </summary>
        /// <param name="left">The <see cref="{{currentType}}"/> value to compare.</param>
        /// <param name="right">The <see cref="{{name}}"/> value to compare.</param>
        /// <returns><see langword="true"/> if <paramref name="left"/> is less than <paramref name="right"/>; otherwise, <see langword="false"/>.</returns>
        public static bool operator <({{currentType}} left, {{name}} right) => {{(useDirectCompare ? "left < right.value" : "right.CompareTo(left) > 0")}};

        /// <summary>
        /// Returns a value indicating whether a <see cref="{{currentType}}"/> value is greater than or equal to a <see cref="{{name}}"/> value.
        /// </summary>
        /// <param name="left">The <see cref="{{currentType}}"/> value to compare.</param>
        /// <param name="right">The <see cref="{{name}}"/> value to compare.</param>
        /// <returns><see langword="true"/> if <paramref name="left"/> is greater than or equal to <paramref name="right"/>; otherwise, <see langword="false"/>.</returns>
        public static bool operator >=({{currentType}} left, {{name}} right) => {{(useDirectCompare ? "left >= right.value" : "right.CompareTo(left) <= 0")}};

        /// <summary>
        /// Returns a value indicating whether a <see cref="{{currentType}}"/> value is less than or equal to a <see cref="{{name}}"/> value.
        /// </summary>
        /// <param name="left">The <see cref="{{currentType}}"/> value to compare.</param>
        /// <param name="right">The <see cref="{{name}}"/> value to compare.</param>
        /// <returns><see langword="true"/> if <paramref name="left"/> is less than or equal to <paramref name="right"/>; otherwise, <see langword="false"/>.</returns>
        public static bool operator <=({{currentType}} left, {{name}} right) => {{(useDirectCompare ? "left <= right.value" : "right.CompareTo(left) >= 0")}};
    """;
    }

    private static IEnumerable<string> CreateCreateMethods(string name, string backingType)
    {
        if (backingType == "Int64")
        {
            yield return $"private static {name} Create(Int32 value) => new(value);";
            yield return $"private static {name} Create(Int64 value) => new(value.BalancedModulo(MaxValueConstant));";
            yield return $"private static {name} Create(Int128 value) => new(value.BalancedModulo(MaxValueConstant));";
        }
        else if (backingType == "Int32")
        {
            yield return $"private static {name} Create(Int32 value) => new(value.BalancedModulo(MaxValueConstant));";
            yield return $"private static {name} Create(Int64 value) => new((Int32)value.BalancedModulo((Int64)MaxValueConstant));";
            yield return $"private static {name} Create(Int128 value) => new((Int32)value.BalancedModulo((Int64)MaxValueConstant));";
        }
        else
        {
            yield return $"private static {name} Create({backingType} value) => new(({backingType})((Int32)value).BalancedModulo((Int32)MaxValueConstant));";
            yield return $"private static {name} Create(Int32 value) => new(({backingType})(value.BalancedModulo((Int32)MaxValueConstant)));";
            yield return $"private static {name} Create(Int64 value) => new(({backingType})(value.BalancedModulo((Int64)MaxValueConstant)));";
            yield return $"private static {name} Create(Int128 value) => new(({backingType})value.BalancedModulo((Int64)MaxValueConstant));";
        }
    }

    private string GenerateArithmeticOperators(string name, string backingType)
    {
        var castType = backingType switch
        {
            "Int64" => "(Int128)",
            "Int32" => "(Int64)",
            _ => ""
        };
        
        return $"""

               // Ternary arithmetic operators
               /// <summary>
               /// Adds two ternary numbers together, maintaining the original numeric type.
               /// </summary>
               /// <param name="left">The first ternary number.</param>
               /// <param name="right">The second ternary number.</param>
               /// <returns>A new ternary number of the same type containing the sum.</returns>
               public static {name} operator +({name} left, {name} right) => Create({castType}left.value + right.value);

               /// <summary>
               /// Subtracts the second ternary number from the first, maintaining the original numeric type.
               /// </summary>
               /// <param name="left">The number to subtract from.</param>
               /// <param name="right">The number to subtract.</param>
               /// <returns>A new ternary number of the same type containing the difference.</returns>
               public static {name} operator -({name} left, {name} right) => Create({castType}left.value - right.value);

               /// <summary>
               /// Multiplies two ternary numbers together, maintaining the original numeric type.
               /// </summary>
               /// <param name="left">The first number to multiply.</param>
               /// <param name="right">The second number to multiply.</param>
               /// <returns>A new ternary number of the same type containing the product.</returns>
               public static {name} operator *({name} left, {name} right) => Create({castType}left.value * right.value);

               /// <summary>
               /// Divides the first ternary number by the second, maintaining the original numeric type.
               /// </summary>
               /// <param name="left">The dividend.</param>
               /// <param name="right">The divisor.</param>
               /// <returns>A new ternary number of the same type containing the quotient.</returns>
               public static {name} operator /({name} left, {name} right) => Create(left.value / right.value);

               /// <summary>
               /// Computes the remainder after dividing the first ternary number by the second.
               /// </summary>
               /// <param name="left">The dividend.</param>
               /// <param name="right">The divisor.</param>
               /// <returns>A new ternary number of the same type containing the remainder.</returns>
               public static {name} operator %({name} left, {name} right) => Create(left.value % right.value);

               // Unary arithmetic operators
               /// <summary>
               /// Returns the negation of a ternary number, maintaining the original numeric type.
               /// </summary>
               /// <param name="value">The ternary number to negate.</param>
               /// <returns>A new ternary number of the same type containing the negated value.</returns>
               public static {name} operator -({name} value) => Create(-value.value);

               /// <summary>
               /// Returns the same ternary number (unary plus operator).
               /// </summary>
               /// <param name="value">The ternary number.</param>
               /// <returns>The same ternary number.</returns>
               public static {name} operator +({name} value) => value;

               // Mixed arithmetic operators
               /// <summary>
               /// Adds a ternary number and a native numeric value, maintaining the original ternary type.
               /// </summary>
               /// <param name="left">The ternary number.</param>
               /// <param name="right">The native numeric value to add.</param>
               /// <returns>A new ternary number containing the sum.</returns>
               public static {name} operator +({name} left, {backingType} right) => Create({castType}left.value + right);

               /// <summary>
               /// Adds a native numeric value and a ternary number, maintaining the original ternary type.
               /// </summary>
               /// <param name="left">The native numeric value to add.</param>
               /// <param name="right">The ternary number.</param>
               /// <returns>A new ternary number containing the sum.</returns>
               public static {name} operator +({backingType} left, {name} right) => Create({castType}left + right.value);

               /// <summary>
               /// Subtracts a native numeric value from a ternary number, maintaining the original ternary type.
               /// </summary>
               /// <param name="left">The ternary number to subtract from.</param>
               /// <param name="right">The native numeric value to subtract.</param>
               /// <returns>A new ternary number containing the difference.</returns>
               public static {name} operator -({name} left, {backingType} right) => Create({castType}left.value - right);

               /// <summary>
               /// Subtracts a ternary number from a native numeric value, maintaining the original ternary type.
               /// </summary>
               /// <param name="left">The native numeric value.</param>
               /// <param name="right">The ternary number to subtract.</param>
               /// <returns>A new ternary number containing the difference.</returns>
               public static {name} operator -({backingType} left, {name} right) => Create({castType}left - right.value);

               /// <summary>
               /// Multiplies a ternary number by a native numeric value, maintaining the original ternary type.
               /// </summary>
               /// <param name="left">The ternary number.</param>
               /// <param name="right">The native numeric value to multiply by.</param>
               /// <returns>A new ternary number of the same type containing the product.</returns>
               public static {name} operator *({name} left, {backingType} right) => Create({castType}left.value * right);

               /// <summary>
               /// Multiplies a native numeric value by a ternary number, maintaining the original ternary type.
               /// </summary>
               /// <param name="left">The native numeric value.</param>
               /// <param name="right">The ternary number to multiply by.</param>
               /// <returns>A new ternary number containing the product.</returns>
               public static {name} operator *({backingType} left, {name} right) => Create({castType}left * right.value);

               /// <summary>
               /// Divides a ternary number by a native numeric value, maintaining the original ternary type.
               /// </summary>
               /// <param name="left">The ternary number to divide.</param>
               /// <param name="right">The native numeric value to divide by.</param>
               /// <returns>A new ternary number of the same type containing the quotient.</returns>
               public static {name} operator /({name} left, {backingType} right) => Create(left.value / right);

               /// <summary>
               /// Divides a native numeric value by a ternary number, maintaining the original ternary type.
               /// </summary>
               /// <param name="left">The native numeric value to divide.</param>
               /// <param name="right">The ternary number to divide by.</param>
               /// <returns>A new ternary number containing the quotient.</returns>
               public static {name} operator /({backingType} left, {name} right) => Create(left / right.value);

               /// <summary>
               /// Computes the remainder after dividing a ternary number by a native numeric value, maintaining the original ternary type.
               /// </summary>
               /// <param name="left">The ternary number to divide.</param>
               /// <param name="right">The native numeric value to divide by.</param>
               /// <returns>A new ternary number of the same type containing the remainder.</returns>
               public static {name} operator %({name} left, {backingType} right) => Create(left.value % right);

               /// <summary>
               /// Computes the remainder after dividing a native numeric value by a ternary number, maintaining the original ternary type.
               /// </summary>
               /// <param name="left">The native numeric value to divide.</param>
               /// <param name="right">The ternary number to divide by.</param>
               /// <returns>A new ternary number containing the remainder.</returns>
               public static {name} operator %({backingType} left, {name} right) => Create(left % right.value);
           """;
    }

    private string GenerateBinaryOperations(string name, string backingType)
    {
        var tritArrayName = $"TritArray{name.Substring(3, name.Length - 4)}";
        
        return $$"""

               /// <summary>
               /// Performs a left shift operation on the ternary number, maintaining the original numeric type.
               /// </summary>
               /// <param name="value">The ternary number to shift.</param>
               /// <param name="shiftAmount">The number of positions to shift left. Negative values result in a right shift.</param>
               /// <returns>A new ternary number of the same type containing the shifted value.</returns>
               public static {{name}} operator <<({{name}} value, int shiftAmount) => Create(value.value.Shift(-shiftAmount));

               /// <summary>
               /// Performs a right shift operation on the ternary number, maintaining the original numeric type.
               /// </summary>
               /// <param name="value">The ternary number to shift.</param>
               /// <param name="shiftAmount">The number of positions to shift right. Negative values result in a left shift.</param>
               /// <returns>A new ternary number of the same type containing the shifted value.</returns>
               public static {{name}} operator >> ({{name}} value, int shiftAmount) => Create(value.value.Shift(shiftAmount));

               /// <summary>
               /// Performs an unsigned right shift operation on the ternary number, maintaining the original numeric type.
               /// In this implementation, it behaves the same as the signed right shift.
               /// </summary>
               /// <param name="value">The ternary number to shift.</param>
               /// <param name="shiftAmount">The number of positions to shift right. Negative values result in a left shift.</param>
               /// <returns>A new ternary number of the same type containing the shifted value.</returns>
               public static {{name}} operator >>> ({{name}} value, int shiftAmount) => Create(value.value.Shift(shiftAmount));

               /// <summary>
               /// Applies a unary operation to each trit in this ternary number. This operation converts the number to a TritArray.
               /// </summary>
               /// <param name="value">The ternary number to convert and operate on.</param>
               /// <param name="operation">The unary operation to apply to each trit.</param>
               /// <returns>A new TritArray containing the result of applying the operation.</returns>
               /// <remarks>This operation causes an implicit conversion to TritArray before applying the operation.</remarks>
               public static {{tritArrayName}} operator |({{name}} value, Func<Trit, Trit> operation)
               {
                   {{tritArrayName}} array = value;
                   return array | operation;
               }

               /// <summary>
               /// Combines each trit in this ternary number with the corresponding trit in the provided array. This operation converts the number to a TritArray.
               /// </summary>
               /// <param name="value">The ternary number to convert and combine.</param>
               /// <param name="trits">The array of trits to combine with.</param>
               /// <returns>A new TritArray containing the result of the operation.</returns>
               /// <remarks>This operation causes an implicit conversion to TritArray before combining with the provided trits.</remarks>
               public static {{tritArrayName}} operator |({{name}} value, Trit[] trits)
               {
                   {{tritArrayName}} array = value;
                   return array | trits;
               }
               """;
    }
#>
